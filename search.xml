<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu记录]]></title>
    <url>%2F2017%2F11%2F13%2Fubuntu%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1. 创建桌面应用图标在终端输入以下命令:1sudo gedit /usr/share/applications/AndroidStudio.desktop 在打开的文档中添加下面的内容：12345678[Desktop Entry]Name=Android StudioComment=android studioExec=/home/czd/soft/android-studio/bin/studio.shIcon=/home/czd/soft/android-studio/bin/studio.pngTerminal=falseType=ApplicationCategories=Application 保存、关闭后，会在/usr/share/applications中看到Android Studio的快捷方式，复制到桌面双击图标就可使用了打开application文件夹:1sudo nautilus /usr/share/applications 需要注意的是，每一行必须紧靠左侧且每行最后面不能有空格，否则会失败 Exec代表应用程序的位置【视实际情况修改】 Icon代表应用程序图标的位置【视实际情况修改】 Terminal的值为false表示启动时不启动命令行窗口，值为true表示启动命令行窗口【建议为false】 Categories这里的内容决定创建出的起动器在应用程序菜单中的位置，按照上面的写法创建的起动器将出现在应用程序－Internet中，以此类推，如果想在应用程序－办公中创建起动器，上述最后一行应该写成：Categories=Application;Office; 2. 下载repocurl “http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo“ &gt; ~/bin/repo 3. androidstudio中启动emulator闪退的问题1234567891017-11-3下午5:17 Emulator: context mismatch in svga_sampler_view_destroy下午5:17 Emulator: context mismatch in svga_sampler_view_destroy下午5:17 Emulator: VMware: vmw_ioctl_command error 无效的参数.下午5:17 ADB rejected shell command (getprop): closed下午5:17 Emulator: Process finished with exit code 134 (interrupted by signal 6: SIGABRT) 打开1~/.android/avd/模拟器名称&lt;&gt;/config.ini 方法一：修改为12hw.gpu.enabled=nohw.gpu.mode=mesa 方法二：修改为12hw.gpu.enabled=nohw.gpu.mode=swiftshader 4.模拟器无法启动1sudo apt-get install lib64stdc++6 进入/emulator/lib64 文件夹,备份已有的libstdc++.so.6 文件123mv libstdc++.so.6 libstdc++.so.6.bakln -s /usr/lib64/libstdc++.so.6 &lt;sdk目录&gt;/emulator/lib64/libstdc++ 最后启动模拟器 ok 搞定。]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Ubuntu 使用记录</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[framework笔记三 启动]]></title>
    <url>%2F2017%2F11%2F13%2Fframework%E7%AC%94%E8%AE%B0%E4%B8%89-%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Android 启动过程 通电后，Bootloader 引导 在Bootloader运行期间，按下预定义的组合键，可以进入系统Fastboot模式和Recover模式。 装在和启动Linux内核 Bootloader会吧boot.img映像装在进内存 启动Init进程 Init进程是系统的第一个进程 Init进程会解析Linux的配置脚本init.rc文件 最后Init进程会作为守护进程来执行修改属性请求，启动崩溃的进程等操作 启动ServiceManager 主要作用是管理Binder服务，负责Binder服务的注册与查找 启动Zygote进程 Zygote进程负责fork出应用进程，是所有应用进程的父进程 创建Dalivik虚拟机，预装在系统的资源文件和Java类 Zygote进程也将变成守护进程，负责响应启动APK应用程序的请求 启动SystemServer Zygote进程fork出的第一个进程，也是整个Android系统的核心进程 首先启动本地服务SensorService，接着启动包括ActivityMangeerService、WindowsManagerService、PackageMangerService在内的所有Java服务 启动MediaServer MediaServer是有Init进程启动，包含多媒体相关的本地Binder服务，包括CameraService、AudioFlingerService、MediaPlagerService和AudioPolicyService。 启动Launcher SystemServer加载完所有Java服务后，最后会调用ActivityMangerService的SystemReady()方法。会发出Intent “android.intent.category.HOME”]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[framework笔记二 源码结构、Android.mk]]></title>
    <url>%2F2017%2F11%2F13%2Fframework%E7%AC%94%E8%AE%B0%E4%BA%8C-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E3%80%81Android-mk%2F</url>
    <content type="text"><![CDATA[源码结构 Android.mk分析一个典型文件: package/apps/Settings目录下的Android.mk： 12345678910111213141516171819202122232425262728LOCAL_PATH:= $(call my-dir) //设置LOCAL_PATH为当前目录include $(CLEAR_VARS) //清空除LCAL_PATH外所有"LOCAL_"变量LOCAL_JAVA_LIBRARIES := bouncycastle conscrypt telephony-common //指定依赖的共享Java类库LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4 android-support-v13 jsr305 //指定依赖的静态Java类库LOCAL_MODULE_TAGS := optional //定义模块的标签为optionalLOCAL_SRC_FILES := \ //定义源文件列表 $(call all-java-files-under, src) \ src/com/android/settings/EventLogTags.logtagsLOCAL_RESOURCE_DIR := $(LOCAL_PATH)/res LOCAL_PACKAGE_NAME := Settings //指定模块名称LOCAL_CERTIFICATE := platform //指定模块签名使用paltform签名LOCAL_PRIVILEGED_MODULE := true //true表示此apk将安装到priv-app下，Android4.4新标志LOCAL_PROGUARD_FLAG_FILES := proguard.flags //指定混淆的标志include frameworks/opt/setupwizard/navigationbar/common.mk include $(BUILD_PACKAGE) //指定编译模块的类型为APK# Use the following include to make our test apk. ifeq (,$(ONE_SHOT_MAKEFILE))include $(call all-makefiles-under,$(LOCAL_PATH)) //将源码目录下其余的Android.mk都包含进endif 基本： LOCAL_PATH := $(call my-dir) 定义了当前模块的相对路径 include $(CLEAR_VARS) 清除当前环境变量 除了LOCAL_PATH LOCAL_MODULE := test 编译生成的目标名称 LOCAL_SRC_FILES := $(LOCAL_MODULE).apk 编译该模块需要的源文件 include $(BUILD_PREBUILT) 编译所生成的目标文件格式 编译生成apk: LOCAL_PATH := $(call my-dir) 定义了当前模块的相对路径 include $(CLEAR_VARS) 清除当前环境变量 除了LOCAL_PATH LOCAL_SRC_FILES := $(call all-subdir-java-files) 调用工具将源码编译生成apk LOCAL_PACKAGE_NAME:= XXX 编译生成apk的名字include $(BUILD_PACKAGE) 编译生成apk 编译生成jar包： LOCAL_PATH := $(call my-dir) 定义了当前模块的相对路径 include $(CLEAR_VARS) 清除当前环境变量 除了LOCAL_PATH LOCAL_SRC_FILES := $(call all-subdir-java-files) 调用工具将源码编译生成apk LOCAL_MODULE ：= com.text.mjar jar包名字 include $(BUILD_STATIC_JAVA_LIBRARY): 编译成静态jar包 include $(BUILD_JAVA_LIBRARY): 编译生成共享jar包 静态jar包：include $(BUILD_STATIC_JAVA_LIBRARY)使用.class 文件打包而成的jar文件，可以在任何java虚拟机运行 动态jar包：include $(BUILD_JAVA_LIBRARY)在静态jar包基础之上使用.dex打包而成的jar文件，.dex是android系统使用的文件格式。 apk依赖于jar包： LOCAL_PATH := $(call my-dir) 定义了当前模块的相对路径 include $(CLEAR_VARS) 清除当前环境变量 除了LOCAL_PATH LOCAL_STATIC_JAVA_LIBRARIES:= static-library 引入静态jar包 LOCAL_JAVA_LIBRARIES:=share-library 映入动态jar包 LOCAL_SRC_FILES:=$(call all-subdir-java-files) LOCAL_PACKAGE_NAME:=localPackage include $(BUILD_JAVA_LIBRARY): 编译生成共享jar包 预编译jar包： LOCAL_PATH := $(call my-dir) 定义了当前模块的相对路径 include $(CLEAR_VARS) 清除当前环境变量 除了LOCAL_PATH LOCAL_MODULE_CLASS:=JAVA_LIBRARIES 指定编译生成文件类型 LOCAL_MODULE ：= com.text.mjar jar包名字 LOCAL_SRC_FILES := com.test.static include $(BUILD_PREBUILT) 预编译 LOCAL_MODULE_CLASS ： JAVA_LIBRARIES: dex归档文件 APP：APK文件 SHARED_LIBRARIES: 动态库文件 EXECUTABLES: 二进制文件 ETC： 其他文件格式]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[framework笔记 一 编译过程]]></title>
    <url>%2F2017%2F11%2F13%2Fframework%E7%AC%94%E8%AE%B0-%E4%B8%80-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[原文地址 编译过程按照google给出的编译步骤如下： source build/envsetup.sh加载命令 lunch选择平台编译选项 make 执行编译 1. source build/envsetup.sh这个命令是用来将envsetup.sh里的所有用到的命令加载到环境变量里去 envsetup.sh其主要作用如下： 加载了编译时使用到的函数命令，如：help，lunch，m，mm，mmm等 添加了两个编译选项：generic-eng和simulator，这两个选项是系统默认选项 查找vendor(device)/&lt;-厂商目录&gt;/和vendor(device)/&lt;厂商目录&gt;/build/目录下的vendorsetup.sh，如果存在的话，加载执行它，添加厂商自己定义产品的编译选项 其中包括下面的代码很重要，它要从device 和 vendor目录下查找vendorsetup.sh文件，如果查到了，就加载它 12345678# Execute the contents of any vendorsetup.sh files we can find.for f in `test -d device &amp;&amp; find -L device -maxdepth 4 -name 'vendorsetup.sh' 2&gt; /dev/null` \ `test -d vendor &amp;&amp; find -L vendor -maxdepth 4 -name 'vendorsetup.sh' 2&gt; /dev/null`do echo "including $f" . $fdoneunset f 2. lunch所以如果要想定义自己的产品编译项，在厂商目录下新建一个项目文件夹，然后新建一个vendorsetup.sh，在里面添加上自己的产品编译项，例如1add_lunch_combo xxx_xxx_xxx 这样，当我们在执行source build/envsetup.sh命令的时候，可以在shell上看到下面的信息：1including device/mstar/xxx/vendorsetup.sh 然后执行lunch命令，shell上看到123456789101112131415You&apos;re building on LinuxLunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. aosp_ican_m2-userdebug 8. mstaraddon-eng 9. aosp_tomato-userdebug ... 1x. xxx_xxx_xxx 上面可以看到xxx-eng前面xxx表示产品名称，eng是产品编译类型 eng 工程机 user 最终用户机 userdebug 调试测试机 3. make执行make命令的结果就是去执行当前目录下的Makefile文件，我们来看下它的内容： 123### DO NOT EDIT THIS FILE ###include build/core/main.mk### DO NOT EDIT THIS FILE ### 再看下build/core/main.mk main.mk文件是Android Build系统的主控文件，从main.mk开始，将通过include命令将其所有需要的.mk文件包含进来，最终在内存中形成一个包括所有编译脚本的集合。 Build系统主要编译脚本介绍 在《深入解析Android系统5.0》 17页 文件名 说明 main.mk Android Build系统的主控文件。该文件主要作用是包含进其他mk文件，以及定义几个最重要的便宜目标，如droid、sdk、ndk等。同事检查编译工具的版本，如make、gcc、javac等 help.mk Android Build系统的帮助。输入“make help”会打印出Build系统的使用说明 envsetup.mk 包含进produc_config.mk文件并根据其内容涉笔编译产品所需要的环境变量，并检查这些变量值的合法性，同时还指定了各种编译结果的输出路径 product_config.mk 包含进了系统中所有AndroidProdut.mk文件，并根据当前产品的配置文件来设置产品编译相关的变量 product.mk 定义product_config文件中使用的各种函数 combo/select.mk 根据环境变量设置，指定对应的系统和架构中所使用的编译工具路径 clang/config.mk 定义了LLVM编译器clang在不同架构下的路径和参数 … … Makefile 定义了系统最终编译完成所需要的各种目标和规则 make缺省编译目标是droid.1234567891011121314151617# Building a full system-- the default is to build droidcoredroid: droidcore dist_filesdroidcore: files \ systemimage \ //用来产生system.img $(INSTALLED_BOOTIMAGE_TARGET) \ //用来产生bootimg $(INSTALLED_RECOVERYIMAGE_TARGET) \ //用来产生recover.img $(INSTALLED_USERDATAIMAGE_TARGET) \ //用来产生userdata.img $(INSTALLED_CACHEIMAGE_TARGET) \ //用来产生cache.img $(INSTALLED_VENDORIMAGE_TARGET) \ //用来产生vendor.img $(INSTALLED_FILES_FILE) //用来产生installed-files.txt文件，该文件将会放在out/target/product/&lt;product_name&gt;下。文件的内容是当前产品配置将要那幢的所有文件列表 files: prebuilt \ $(modules_to_install) \ //modules_to_intall 变量是当前产品配置下所有将要安装的模块的列表。因此，该目标将导致所有这些模块编译 $(INSTALLED_ANDROID_INFO_TXT_TARGET)//用来产生名为android-info.txt文件，该文件将会存放在out/target/product/&lt;product_name&gt;下。文件的内容是当前产品的设备信息prebuilt: $(ALL_PREBUILT) //用来产生所有在变量GRANDFATHERED_ALL_PREBUILT中的文件 除了droid及其相关目标，Build系统里还有很多可以独立使用的目标： 目标 说明 make clean 清除所有编译结果，相当于”rm out -rf” make snod 重新生成最终的image温家U呢，但是不再重新编译模块 make help 打印build系统简单的帮助信息 make sdk 生成Android SDK make offline-sdk-docs 为SDK生成HTML版的文档 make doc-comment-check-docs 检查HTML doc是否有效，但是不生成HTML make libandroid_runtime 编译出所有framework的JNT库 make framework 编译出所有framework的jar包 make services 编译出系统服务及相关的模块 make update-api 添加系统API或者修改@hide的API后，需要执行，然后再make Android 的产品配置文件如果用户想个性定制自己的产品，应该有以下流程： 创建公司项目目录 1mkdir device/mstar/xxx_x1 创建一个vendorsetup.sh文件，将当前产品编译项添加到lunch里，让lunch能找到用户个性定制的编译项. 1echo "add_lunch_combo xxx_x1-userdebug" &gt; device/xxx_x1/vendorsetup.sh 仿着Android示例代码，创建2个mk文件 1touch device/xxx_x1/AnroidProduct.mk device/xxx_x1/xxx_x1.ml 4.在AndroidProduct.mk里添加如下内容，表示只有一个产品xxx_x1，它对应的配置文件在当前目录下的xxx_x1.mk。12PRODUCT_MAKEFILES := \ $(LOCAL_DIR)/xxx_x1.mk 5.在产品配置文件添加最基本信息xxx_x1.mk12345678# Inherit from hardware-specific part of the product configuration.$(call inherit-product, device/mstar/xxx_x1/device.mk)# Set those variables here to overwrite the inherited values.PRODUCT_NAME := xxx_x1 //产品名称PRODUCT_DEVICE := xxx_x1 //产品设备名称PRODUCT_BRAND := MStar //产品的品牌PRODUCT_MODEL := MStar Android TV //产品型号PRODUCT_MANUFACTURER := MStar Semiconductor, Inc. //产品制造商 6.BoardConifg.mk BoardConifg.mk文件被Build系统的envsetup.sh文件包含进去，这个文件主要定义了设备硬件(包括CPU、WIFI、GPS等)相关的一些参数 7.device.mk device.mk 是产品配置中经常需要修改的一个文件。产品定义中需要包含进的模块，文件以及各种环境变量的定义一般都放在这个文件里。device.mk中一些重要的编译变量如下： DEVICE_SOURCES: 源文件位置 PRODUCT_COPY_FILES： 一个格式为”源文件路径：目标文件路径“字符串的集合。使用PRODUCT_COPY_FILES变量能方便地编译目录下的一个文件复制到目标文件系统中 PRODUCT_PROPERTY_OVERRIDES：定义系统的数属性值。一旦设置，不能改变 ”ro.“ 开头，属性是只读属性 ”persist.“ 开头，值将写入/data/property中。可读可写 PRODUCT_PACKAGES：用来定义产品的模块列表，所有在模块列表中的模块的定义都会被执行]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝牙开发 传统蓝牙API的使用一、(启用，发现，查找设备)]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E4%BC%A0%E7%BB%9F%E8%93%9D%E7%89%99API%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80%E3%80%81-%E5%90%AF%E7%94%A8%EF%BC%8C%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%9F%A5%E6%89%BE%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[官方文档 本文将介绍如何使用传统蓝牙。传统蓝牙适用于电池使用强度较大的操作，例如 Android 设备之间的流式传输和通信等。 针对具有低功耗要求的蓝牙设备，Android 4.3（API 级别 18）中引入了面向低功耗蓝牙的 API 支持。 如需了解更多信息，请参阅低功耗蓝牙。 基础知识本文将介绍如何使用 Android Bluetooth API 来完成使用蓝牙进行通信的四项主要任务： 设置蓝牙 查找局部区域内的配对设备或可用设备 连接设备 设备之间传输数据。 android.bluetooth 包中提供了所有 Bluetooth API。 下面概要列出了创建蓝牙连接所需的类和接口： BluetoothAdapter 表示本地蓝牙适配器（蓝牙无线装置）。 BluetoothAdapter 是所有蓝牙交互的入口点。 利用它可以发现其他蓝牙设备，查询绑定（配对）设备的列表，使用已知的 MAC 地址实例化 BluetoothDevice，以及创建 BluetoothServerSocket 以侦听来自其他设备的通信。 BluetoothDevice 表示远程蓝牙设备。利用它可以通过 BluetoothSocket 请求与某个远程设备建立连接，或查询有关该设备的信息，例如设备的名称、地址、类和绑定状态等。 BluetoothSocket 表示蓝牙套接字接口（与 TCP Socket 相似）。这是允许应用通过 InputStream 和 OutputStream 与其他蓝牙设备交换数据的连接点。 BluetoothClass 描述蓝牙设备的一般特征和功能。 这是一组只读属性，用于定义设备的主要和次要设备类及其服务。 不过，它不能可靠地描述设备支持的所有蓝牙配置文件和服务，而是适合作为设备类型提示。 BluetoothProfile 表示蓝牙配置文件的接口。 蓝牙配置文件是适用于设备间蓝牙通信的无线接口规范。 免提配置文件便是一个示例。 如需了解有关配置文件的详细讨论，请参阅使用配置文件 BluetoothHeadset 提供蓝牙耳机支持，以便与手机配合使用。 其中包括蓝牙耳机和免提（1.5 版）配置文件。 BluetoothA2dp 定义高质量音频如何通过蓝牙连接和流式传输，从一台设备传输到另一台设备。“A2DP”代表高级音频分发配置文件。 BluetoothHealth 表示用于控制蓝牙服务的健康设备配置文件代理。 BluetoothHealthCallback 用于实现 BluetoothHealth 回调的抽象类。您必须扩展此类并实现回调方法，以接收关于应用注册状态和蓝牙通道状态变化的更新内容。 BluetoothHealthAppConfiguration 表示第三方蓝牙健康应用注册的应用配置，以便与远程蓝牙健康设备通信。 BluetoothProfile.ServiceListener 在 BluetoothProfile IPC 客户端连接到服务（即，运行特定配置文件的内部服务）或断开服务连接时向其发送通知的接口。 蓝牙权限12&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN " /&gt; 设置蓝牙1. 获取 BluetoothAdapter所有蓝牙 Activity 都需要 BluetoothAdapter。 要获取 BluetoothAdapter，请调用静态 getDefaultAdapter() 方法。这将返回一个表示设备自身的蓝牙适配器（蓝牙无线装置）的 BluetoothAdapter。 整个系统有一个蓝牙适配器，并且您的应用可使用此对象与之交互。 如果 getDefaultAdapter() 返回 null，则该设备不支持蓝牙，您的操作到此为止。 例如： 12345BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // 设备不支持，将不执行后续操作 return;&#125; 2. 启用蓝牙在开启蓝牙操作前，调用 isEnabled() 以检查当前是否已启用蓝牙。 如果此方法返回 false，则表示蓝牙处于停用状态。 启用蓝牙有2方式： 调用系统activity，然后在回调方法 onActivityResult() 中处理结果，官方文档推荐该方式 12Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);startActivityForResult(enableBtIntent, REQUEST_CODE); 通过BluetoothAdapter的enable())方法 需要BLUETOOTH_ADMIN权限许可。该enable()方法仅用于包括用于更改系统设置的用户界面的应用程序 1boolean enable = mBLEAdater.enable(); 这是一个异步调用：它将立即返回，并且客户端应该监听ACTION_STATE_CHANGED 以获得随后的适配器状态更改的通知。如果此调用返回true，则适配器状态将立即转换STATE_OFF到STATE_TURNING_ON，稍后过渡到任一STATE_OFF或STATE_ON。如果此调用返回false，那么立即出现的问题将阻止适配器打开，例如飞行模式或适配器已打开。 3. 监听状态改变的广播 蓝牙状态改变的广播字段,每当蓝牙状态发生变化时，系统都会广播此 Intent BluetoothAdapter.ACTION_STATE_CHANGED 此广播包含额外字段 EXTRA_STATE 新的蓝牙状态 EXTRA_PREVIOUS_STATE 旧的蓝牙状态 这些额外字段可能的值包括 STATE_TURNING_ON、STATE_ON、STATE_TURNING_OFF 和 STATE_OFF。 12345678910/** * 蓝牙状态变化的广播 */private final BroadcastReceiver mBleStateChangeBroadcast = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; int intExtra = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR); &#125;&#125;; 查找设备使用 BluetoothAdapter，您可以通过设备发现或通过查询配对（绑定）设备的列表来查找远程蓝牙设备。 设备发现是一个扫描过程，它会搜索局部区域内已启用蓝牙功能的设备，然后请求一些关于各台设备的信息（有时也被称为“发现”、“查询”或“扫描”）。但局部区域内的蓝牙设备仅在其当前已启用可检测性时才会响应发现请求。 如果设备可检测到，它将通过共享一些信息（例如设备名称、类及其唯一 MAC 地址）来响应发现请求。 利用此信息，执行发现的设备可以选择发起到被发现设备的连接。 在首次与远程设备建立连接后，将会自动向用户显示配对请求。 设备完成配对后，将会保存关于该设备的基本信息（例如设备名称、类和 MAC 地址），并且可使用 Bluetooth API 读取这些信息。 利用远程设备的已知 MAC 地址可随时向其发起连接，而无需执行发现操作（假定该设备处于有效范围内）。 请记住，被配对与被连接之间存在差别。被配对意味着两台设备知晓彼此的存在，具有可用于身份验证的共享链路密钥，并且能够与彼此建立加密连接。 被连接意味着设备当前共享一个 RFCOMM 通道，并且能够向彼此传输数据。 当前的 Android Bluetooth API 要求对设备进行配对，然后才能建立 RFCOMM 连接。 （在使用 Bluetooth API 发起加密连接时，会自动执行配对）。 注：Android 设备默认处于不可检测到状态。 用户可通过系统设置将设备设为在有限的时间内处于可检测到状态，或者，应用可请求用户在不离开应用的同时启用可检测性。 查询配对的设备在执行设备发现之前，有必要查询已配对的设备集，以了解所需的设备是否处于已知状态。 为此，请调用 getBondedDevices())。 这将返回表示已配对设备的一组 BluetoothDevice。 官方demo123456789Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();// If there are paired devicesif (pairedDevices.size() &gt; 0) &#123; // Loop through paired devices for (BluetoothDevice device : pairedDevices) &#123; // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + "\n" + device.getAddress()); &#125;&#125; 返回的结合也可以转换成ArrayList12Set&lt;BluetoothDevice&gt; bondedDevices = mBLEAdater.getBondedDevices();ArrayList&lt;BluetoothDevice&gt; bluetoothDeviceArrayList = new ArrayList&lt;&gt;(bondedDevices); 发现设备要开始发现设备，只需调用 startDiscovery()。该进程为异步进程，并且该方法会立即返回一个布尔值，指示是否已成功启动发现操作。 发现进程通常包含约12秒钟的查询扫描，之后对每台发现的设备进行页面扫描，以检索其蓝牙名称。 此处有三个广播可以使用： 开启扫描广播 扫描结束广播 发现到设备的广播 扫描状态1234567891011121314151617181920//注册扫描状态广播监听IntentFilter filter = new IntentFilter();filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED);filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);registerReceiver(mDisconverState, filter); /** * 扫描状态广播 */ private final BroadcastReceiver mDisconverState = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)) &#123; //开始扫描 &#125; else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) &#123; //结束扫描 &#125; &#125; &#125;; 发现设备12345678910111213141516// Create a BroadcastReceiver for ACTION_FOUNDprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); // When discovery finds a device if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // Get the BluetoothDevice object from the Intent BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + "\n" + device.getAddress()); &#125; &#125;&#125;;// Register the BroadcastReceiverIntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy 注意1 ：执行设备发现对于蓝牙适配器而言是一个非常繁重的操作过程，并且会消耗大量资源。 在找到要连接的设备后，确保始终使用 cancelDiscovery() 停止发现，然后再尝试连接。 此外，如果您已经保持与某台设备的连接，那么执行发现操作可能会大幅减少可用于该连接的带宽，因此不应该在处于连接状态时执行发现操作。 注意2 : 发现设备的广播中会多次被调，始终包含额外的字段EXTRA_DEVICE和EXTRA_CLASS。可以包含额外的字段EXTRA_NAME和/或 EXTRA_RSSI可用的。 注意3 : 同一个设备可能被多次扫描到， 返回的name有可能为空，应该对其进行判断，通过mac表示唯一性]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL的使用]]></title>
    <url>%2F2017%2F10%2F20%2FAIDL%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原文地址 AIDL语言设计这门语言的目的是为了实现进程间通信，尤其是在涉及多进程并发情况下的进程间通信。 进程间通信其他方式: BroadcastReceiver BroadcastReceiver占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的 Messenger Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行，在有些要求多进程的情况下不适用 语法 文件类型: 用AIDL书写的文件的后缀是 .aidl 数据类型: AIDL默认支持一些数据类型，除了这些类型之外的数据类型，在使用之前必须导包, 就算目标文件与当前正在编写的 .aidl 文件在同一个包下 默认支持的数据类型包括： Java中的八种基本数据类型，包括 byte，short，int，long，float，double，boolean，char String、CharSequence类型 List类型：List中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。List可以使用泛型。 Map类型：Map中的所有元素必须是AIDL支持的类型之一，或者是一个其他AIDL生成的接口，或者是定义的parcelable。Map是不支持泛型的。 3.定向tag AIDL中的定向 tag 表示了在跨进程通信中数据的流向 in 客户端 -&gt; 服务端 表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动 out 服务端 -&gt; 客户端 表现为服务端将会接收到那个对象的的空对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动 inout 客户端 &lt;-&gt; 服务端 服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动 Java 中的基本类型和 String ，CharSequence 的定向 tag 默认且只能是 in 请不要滥用定向 tag ，而是要根据需要选取合适的——要是不管三七二十一，全都一上来就用 inout ，等工程大了系统的开销就会大很多——因为排列整理参数的开销是很昂贵的。 两种AIDL文件 一类是用来定义parcelable对象，以供其他AIDL文件使用AIDL中非默认支持的数据类型的 一类是用来定义方法接口，以供系统使用来完成跨进程通信的 使用实现Parcelable 接口 非默认支持的数据类型均要实现Parcelable接口 可通过studio插件自动生成 注:studio自动生成的模板类的对象只支持为in的定向 tag,因为只生成了writeToParcel()方法,果要支持为 out 或者 inout 的定向 tag 的话，还需要实现readFromParcel()方法——而这个方法其实并没有在 Parcelable 接口里面，所以需要我们从头写 123456789101112131415@Overridepublic void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(price);&#125;/** * 参数是一个Parcel,用它来存储与传输数据 * @param dest */public void readFromParcel(Parcel dest) &#123; //注意，此处的读值顺序应当是和writeToParcel()方法中一致的 name = dest.readString(); price = dest.readInt();&#125; 创建对象实现Precelable接口 创建对象的.aidl文件 创建操作类接口.aidl文件 Book.aidl 1234package com.ican.com.aidlclientdemo;//注意parcelable是小写parcelable Book; BookManager.aidl 123456789package com.ican.com.aidlclientdemo;//需要引入import can.ican.com.aidlclientdemo.Book;interface BookManager &#123; List&lt;Book&gt; getBoos(); void addBook(out Book book); void setStr(in String str);&#125; 坑 Book.aidl与Book.java的包名应当是一样的。但是由于studio架构，两个文件并不在一个文件目录中，一个是main/java，一个在mian/aidl目录下,所以在buidl的时候会提示Error:(3) couldn&#39;t find import for class can.ican.com.aidlclientdemo.Book。 所以为了方便移植，解决办法是 将Book.java放在main/aidl目录下，和Book.adil同一个包中，在app的build.gradle中，在android模块中，添加1sourceSets &#123; main &#123; java.srcDirs = ['src/main/java', 'src/main/aidl']&#125; &#125; studio在编译的时候，编译.java文件也会编译main/adil目录下的java文件。 两端代码不管aidl在哪段，先写好后将aidl目录复制到另外一段，保证两端aidl报名相同。 1. 服务端12345678910111213141516171819202122232425262728public class AIDLService extends Service &#123; //由AIDL文件生成的BookManager private final BookManager.Stub mBookManager = new BookManager.Stub() &#123; @Override public List&lt;Book&gt; getBooks() throws RemoteException &#123; //实现逻辑处理... &#125; @Override public void addBook(Book book) throws RemoteException &#123; //实现逻辑处理... &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); //初始化... &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBookManager; &#125;&#125; 主要分为三块 onCreate() 方法里面数据的初始化操作 BookManager.Stub中的方法。在这里面提供AIDL里面定义的方法接口的具体实现逻辑 重写 onBind() 方法。在里面返回写好的 BookManager.Stub 然后在Manefest注册写好的Service12345678&lt;service android:name=".AIDLService" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="ican.can.com.aidlserverdemo.aidl" /&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 2. 客户端123456789101112131415161718192021222324 private BookManager mBookManager = null;/** * 尝试与服务端建立连接 */ private void attemptToBindService() &#123; Intent intent = new Intent(); intent.setAction("ican.can.com.aidlserverdemo.aidl"); intent.setPackage("ican.can.com.aidlserverdemo"); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; private ServiceConnection mServiceCoonection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBookManager = BookManager.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; 获取到BookManager对象后就可以调用接口的实现方法了]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>aidl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP 在局域网内搜索设备(封装)]]></title>
    <url>%2F2017%2F10%2F19%2FUDP-%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E6%90%9C%E7%B4%A2%E8%AE%BE%E5%A4%87-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[原文地址 主要优化的地方： 用户可选择是否携带自定义协议数据。如设备（或主机）可以直接携带设备名称、房间等信息 主机可把设备携带的信息可直接封装在设备对象中 原理回顾主机与设备在同一局域网中，它们与路由器的连接为有线或无线。 这样就能获取到设备的IP地址，接下来就能随心所欲了，如建立TCP连接。 使用方法源码及DEMO 1. 不携带用户数据的使用（最简单的使用）只要实现内部的抽象方法即可。 主机： 123456789101112131415161718new SearcherHost() &#123; @Override public void onSearchStart() &#123; ... &#125; @Override public void onSearchFinish(Set deviceSet) &#123; //所有设备集合都在deviceSet中，通过getIp()可获取设备IP，getPort()获取端口 ... &#125; @Override public void printLog(String log) &#123; ... &#125;&#125;.search(); 设备： 1234567891011121314151617181920// 创建设备SearcherDevice mSearcherDevice = new SearcherDevice() &#123; @Override public void onDeviceSearched(InetSocketAddress inetSocketAddress) &#123; // 主机IP: inetSocketAddress.getAddress().getHostAddress() // 主机端口：inetSocketAddress.getPort() ... &#125; @Override public void printLog(String s) &#123; ... &#125;&#125;;// 打开设备mSearcherDevice.open();// 关闭设备mSearcherDevice.close(); 2. 携带用户数据的使用若需要携带用户数据，必须重写类的用户数据打包与解包方法。 主机： 【可选】在构造方法中，指定泛型的具体类型。若不指定，parseUserData()也许需要强转。 在构造方法中，设置用于接收设备用户数据的最大字节长度（≥设备发送的用户数据长度） 在构造方法中，设置设备类的字节码，没有重写，则写SearcherHost.DeviceBean.class（用于内部通过反射创建实例对象） 重写两个用户数据打包方法： packUserDataSearch()和packUserDataCheck() 重写用户数据解析方法： parseUserData(byte type, MyDevice device, byte[] userData) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253SearcherHost searcherHost = new SearcherHost&lt;MyDevice&gt;(1024, MyDevice.class) &#123; @Override public void onSearchStart() &#123; ... &#125; @Override public void onSearchFinish(Set deviceSet) &#123; ... &#125; @Override public void printLog(String log) &#123; ... &#125; /** * 重写以下3个方法 */ /** * 打包搜索时数据 */ @Override protected byte[] packUserData_Search() &#123; ... &#125; /** * 打包核对时的数据 */ @Override protected byte[] packUserData_Check() &#123; ... &#125; /** * 解析用户数据 * @param type 类型。搜索申请or搜索确认 * @param device 设备 * @param userData 数据 * * @return true-解析成功 */ @Override public boolean parseUserData(byte type, MyDevice device, byte[] userData) &#123; ... &#125;&#125;;// 开始搜索searcherHost.search(); 设备： 在构造方法中，设置用于接收设备用户数据的最大字节长度（≥主机发送的用户数据长度） 重写设备响应时的用户数据打包方法： packUserData() 重写用户数据解析方法： parseUserData(byte type, byte[] userData) 【可选】重写判断是否为本机ip地址的方法（主要用于判断主机确认返回的ip地址是否正确，默认返回true）： isOwnIp(String ip) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SearcherDevice searcherDevice = new SearcherDevice(1024) &#123; @Override public void onDeviceSearched(InetSocketAddress inetSocketAddress) &#123; ... &#125; @Override public void printLog(String s) &#123; ... &#125; /** * 重写以下2个方法 */ /** * 响应时的打包数据 */ @Override protected byte[] packUserData() &#123; ... &#125; /** * 解析用户数据 * @param type 类型，搜索请求or搜索确认 * @param userData 用户数据 * @return 解析结果是否成功 */ @Override public boolean parseUserData(byte type, byte[] userData) &#123; ... &#125; /** * 判断ip是否是本机ip * @param ip 判断的ip地址 * @return */ @Override public boolean isOwnIp(String ip) &#123; ... &#125;&#125;;searcherDevice.open();]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>socket</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP 在局域网内搜索设备(原理)]]></title>
    <url>%2F2017%2F10%2F19%2FUDP-%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E6%90%9C%E7%B4%A2%E8%AE%BE%E5%A4%87-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文地址 原理分析这些设备在局域网内，肯定是通过DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）来获取内网IP的。也就是说每个设备的IP都不是固定的。而我们主要目的就是要获取这些设备的IP地址。 也许你说，把手机设置成一个固定的内网IP，然后让这些设备来连接这个固定IP。看上去OK啊，但万一这个IP被占用了，怎办？ 每个设备的IP会变，但通信端口我们肯定可以固定。这就可以运用上面的UDP广播（或组播）技术。具体流程： 主机（Android手机）发送广播信息，并指定对方接收端口为devicePort； 自己的发送端口为系统分配的hostPort，封装在DatagramSocket中，开始监听此端口。防丢失，一共发三次，每次发送后就监听一段时间； 设备监听devicePort端口，收到信息后。首先解析数据验证是否是自己人（协议）发过来的，否，扔；是，则通过数据报获取对方的IP地址与端口hostPort； 设备通过获取到的IP地址与端口hostPort，给主机发送响应信息； 主机收到设备的响应，就可以知道设备的IP地址了。同时主机返回确认信息给设备，防止设备发给主机的响应信息丢失，毕竟是UDP； 有了IP地址，就可以为所欲为了，比如：建立安全连接TCP。 下面是广播实现的代码，当然也可以用组播来实现。组播因为组播地址的原因，可以进一步加强安全性，代码中把广播的网络那块改成组播就好了 代码实现主机 – 搜索类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266import android.util.Log;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketTimeoutException;import java.nio.charset.Charset;import java.util.HashSet;import java.util.Set;/** * 设备搜索类 * Created by zjun on 2016/9/3. */public abstract class DeviceSearcher extends Thread &#123; private static final String TAG = DeviceSearcher.class.getSimpleName(); private static final int DEVICE_FIND_PORT = 9000; private static final int RECEIVE_TIME_OUT = 1500; // 接收超时时间 private static final int RESPONSE_DEVICE_MAX = 200; // 响应设备的最大个数，防止UDP广播攻击 private static final byte PACKET_TYPE_FIND_DEVICE_REQ_10 = 0x10; // 搜索请求 private static final byte PACKET_TYPE_FIND_DEVICE_RSP_11 = 0x11; // 搜索响应 private static final byte PACKET_TYPE_FIND_DEVICE_CHK_12 = 0x12; // 搜索确认 private static final byte PACKET_DATA_TYPE_DEVICE_NAME_20 = 0x20; private static final byte PACKET_DATA_TYPE_DEVICE_ROOM_21 = 0x21; private DatagramSocket hostSocket; private Set&lt;DeviceBean&gt; mDeviceSet; private byte mPackType; private String mDeviceIP; DeviceSearcher() &#123; mDeviceSet = new HashSet&lt;&gt;(); &#125; @Override public void run() &#123; try &#123; onSearchStart(); hostSocket = new DatagramSocket(); // 设置接收超时时间 hostSocket.setSoTimeout(RECEIVE_TIME_OUT); byte[] sendData = new byte[1024]; InetAddress broadIP = InetAddress.getByName("255.255.255.255"); DatagramPacket sendPack = new DatagramPacket(sendData, sendData.length, broadIP, DEVICE_FIND_PORT); for (int i = 0; i &lt; 3; i++) &#123; // 发送搜索广播 mPackType = PACKET_TYPE_FIND_DEVICE_REQ_10; sendPack.setData(packData(i + 1)); hostSocket.send(sendPack); // 监听来信 byte[] receData = new byte[1024]; DatagramPacket recePack = new DatagramPacket(receData, receData.length); try &#123; // 最多接收200个，或超时跳出循环 int rspCount = RESPONSE_DEVICE_MAX; while (rspCount-- &gt; 0) &#123; recePack.setData(receData); hostSocket.receive(recePack); if (recePack.getLength() &gt; 0) &#123; mDeviceIP = recePack.getAddress().getHostAddress(); if (parsePack(recePack)) &#123; Log.i(TAG, "@@@zjun: 设备上线：" + mDeviceIP); // 发送一对一的确认信息。使用接收报，因为接收报中有对方的实际IP，发送报时广播IP mPackType = PACKET_TYPE_FIND_DEVICE_CHK_12; recePack.setData(packData(rspCount)); // 注意：设置数据的同时，把recePack.getLength()也改变了 hostSocket.send(recePack); &#125; &#125; &#125; &#125; catch (SocketTimeoutException e) &#123; &#125; Log.i(TAG, "@@@zjun: 结束搜索" + i); &#125; onSearchFinish(mDeviceSet); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (hostSocket != null) &#123; hostSocket.close(); &#125; &#125; &#125; /** * 搜索开始时执行 */ public abstract void onSearchStart(); /** * 搜索结束后执行 * @param deviceSet 搜索到的设备集合 */ public abstract void onSearchFinish(Set deviceSet); /** * 解析报文 * 协议：$ + packType(1) + data(n) * data: 由n组数据，每组的组成结构type(1) + length(4) + data(length) * type类型中包含name、room类型，但name必须在最前面 */ private boolean parsePack(DatagramPacket pack) &#123; if (pack == null || pack.getAddress() == null) &#123; return false; &#125; String ip = pack.getAddress().getHostAddress(); int port = pack.getPort(); for (DeviceBean d : mDeviceSet) &#123; if (d.getIp().equals(ip)) &#123; return false; &#125; &#125; int dataLen = pack.getLength(); int offset = 0; byte packType; byte type; int len; DeviceBean device = null; if (dataLen &lt; 2) &#123; return false; &#125; byte[] data = new byte[dataLen]; System.arraycopy(pack.getData(), pack.getOffset(), data, 0, dataLen); if (data[offset++] != '$') &#123; return false; &#125; packType = data[offset++]; if (packType != PACKET_TYPE_FIND_DEVICE_RSP_11) &#123; return false; &#125; while (offset + 5 &lt; dataLen) &#123; type = data[offset++]; len = data[offset++] &amp; 0xFF; len |= (data[offset++] &lt;&lt; 8); len |= (data[offset++] &lt;&lt; 16); len |= (data[offset++] &lt;&lt; 24); if (offset + len &gt; dataLen) &#123; break; &#125; switch (type) &#123; case PACKET_DATA_TYPE_DEVICE_NAME_20: String name = new String(data, offset, len, Charset.forName("UTF-8")); device = new DeviceBean(); device.setName(name); device.setIp(ip); device.setPort(port); break; case PACKET_DATA_TYPE_DEVICE_ROOM_21: String room = new String(data, offset, len, Charset.forName("UTF-8")); if (device != null) &#123; device.setRoom(room); &#125; break; default: break; &#125; offset += len; &#125; if (device != null) &#123; mDeviceSet.add(device); return true; &#125; return false; &#125; /** * 打包搜索报文 * 协议：$ + packType(1) + sendSeq(4) + [deviceIP(n&lt;=15)] * packType - 报文类型 * sendSeq - 发送序列 * deviceIP - 设备IP，仅确认时携带 */ private byte[] packData(int seq) &#123; byte[] data = new byte[1024]; int offset = 0; data[offset++] = '$'; data[offset++] = mPackType; seq = seq == 3 ? 1 : ++seq; // can't use findSeq++ data[offset++] = (byte) seq; data[offset++] = (byte) (seq &gt;&gt; 8 ); data[offset++] = (byte) (seq &gt;&gt; 16); data[offset++] = (byte) (seq &gt;&gt; 24); if (mPackType == PACKET_TYPE_FIND_DEVICE_CHK_12) &#123; byte[] ips = mDeviceIP.getBytes(Charset.forName("UTF-8")); System.arraycopy(ips, 0, data, offset, ips.length); offset += ips.length; &#125; byte[] result = new byte[offset]; System.arraycopy(data, 0, result, 0, offset); return result; &#125; /** * 设备Bean * 只要IP一样，则认为是同一个设备 */ public static class DeviceBean&#123; String ip; // IP地址 int port; // 端口 String name; // 设备名称 String room; // 设备所在房间 @Override public int hashCode() &#123; return ip.hashCode(); &#125; @Override public boolean equals(Object o) &#123; if (o instanceof DeviceBean) &#123; return this.ip.equals(((DeviceBean)o).getIp()); &#125; return super.equals(o); &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getRoom() &#123; return room; &#125; public void setRoom(String room) &#123; this.room = room; &#125; &#125;&#125; 主机——demo核心代码： 1234567891011121314151617private List&lt;DeviceSearcher.DeviceBean&gt; mDeviceList;private void searchDevices_broadcast() &#123; new DeviceSearcher() &#123; @Override public void onSearchStart() &#123; startSearch(); // 主要用于在UI上展示正在搜索 &#125; @Override public void onSearchFinish(Set deviceSet) &#123; endSearch(); // 结束UI上的正在搜索 mDeviceList.clear(); mDeviceList.addAll(deviceSet); mHandler.sendEmptyMessage(0); // 在UI上更新设备列表 &#125; &#125;.start();&#125; 设备——设备等待搜索类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201import android.content.Context;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.util.Log;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketTimeoutException;import java.nio.charset.Charset;/** * 设备等待搜索类 * Created by zjun on 2016/9/4. */public abstract class DeviceWaitingSearch extends Thread &#123; private final String TAG = DeviceWaitingSearch.class.getSimpleName(); private static final int DEVICE_FIND_PORT = 9000; private static final int RECEIVE_TIME_OUT = 1500; // 接收超时时间，应小于等于主机的超时时间1500 private static final int RESPONSE_DEVICE_MAX = 200; // 响应设备的最大个数，防止UDP广播攻击 private static final byte PACKET_TYPE_FIND_DEVICE_REQ_10 = 0x10; // 搜索请求 private static final byte PACKET_TYPE_FIND_DEVICE_RSP_11 = 0x11; // 搜索响应 private static final byte PACKET_TYPE_FIND_DEVICE_CHK_12 = 0x12; // 搜索确认 private static final byte PACKET_DATA_TYPE_DEVICE_NAME_20 = 0x20; private static final byte PACKET_DATA_TYPE_DEVICE_ROOM_21 = 0x21; private Context mContext; private String deviceName, deviceRoom; public DeviceWaitingSearch(Context context, String name, String room) &#123; mContext = context; deviceName = name; deviceRoom = room; &#125; @Override public void run() &#123; DatagramSocket socket = null; try &#123; socket = new DatagramSocket(DEVICE_FIND_PORT); byte[] data = new byte[1024]; DatagramPacket pack = new DatagramPacket(data, data.length); while (true) &#123; // 等待主机的搜索 socket.receive(pack); if (verifySearchData(pack)) &#123; byte[] sendData = packData(); DatagramPacket sendPack = new DatagramPacket(sendData, sendData.length, pack.getAddress(), pack.getPort()); Log.i(TAG, "@@@zjun: 给主机回复信息"); socket.send(sendPack); Log.i(TAG, "@@@zjun: 等待主机接收确认"); socket.setSoTimeout(RECEIVE_TIME_OUT); try &#123; socket.receive(pack); if (verifyCheckData(pack)) &#123; Log.i(TAG, "@@@zjun: 确认成功"); onDeviceSearched((InetSocketAddress) pack.getSocketAddress()); break; &#125; &#125; catch (SocketTimeoutException e) &#123; &#125; socket.setSoTimeout(0); // 连接超时还原成无穷大，阻塞式接收 &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; socket.close(); &#125; &#125; &#125; /** * 当设备被发现时执行 */ public abstract void onDeviceSearched(InetSocketAddress socketAddr); /** * 打包响应报文 * 协议：$ + packType(1) + data(n) * data: 由n组数据，每组的组成结构type(1) + length(4) + data(length) * type类型中包含name、room类型，但name必须在最前面 */ private byte[] packData() &#123; byte[] data = new byte[1024]; int offset = 0; data[offset++] = '$'; data[offset++] = PACKET_TYPE_FIND_DEVICE_RSP_11; byte[] temp = getBytesFromType(PACKET_DATA_TYPE_DEVICE_NAME_20, deviceName); System.arraycopy(temp, 0, data, offset, temp.length); offset += temp.length; temp = getBytesFromType(PACKET_DATA_TYPE_DEVICE_ROOM_21, deviceRoom); System.arraycopy(temp, 0, data, offset, temp.length); offset += temp.length; byte[] retVal = new byte[offset]; System.arraycopy(data, 0, retVal, 0, offset); return retVal; &#125; private byte[] getBytesFromType(byte type, String val) &#123; byte[] retVal = new byte[0]; if (val != null) &#123; byte[] valBytes = val.getBytes(Charset.forName("UTF-8")); retVal = new byte[5 + valBytes.length]; retVal[0] = type; retVal[1] = (byte) valBytes.length; retVal[2] = (byte) (valBytes.length &gt;&gt; 8 ); retVal[3] = (byte) (valBytes.length &gt;&gt; 16); retVal[4] = (byte) (valBytes.length &gt;&gt; 24); System.arraycopy(valBytes, 0, retVal, 5, valBytes.length); &#125; return retVal; &#125; /** * 校验搜索数据 * 协议：$ + packType(1) + sendSeq(4) * packType - 报文类型 * sendSeq - 发送序列 */ private boolean verifySearchData(DatagramPacket pack) &#123; if (pack.getLength() != 6) &#123; return false; &#125; byte[] data = pack.getData(); int offset = pack.getOffset(); int sendSeq; if (data[offset++] != '$' || data[offset++] != PACKET_TYPE_FIND_DEVICE_REQ_10) &#123; return false; &#125; sendSeq = data[offset++] &amp; 0xFF; sendSeq |= (data[offset++] &lt;&lt; 8 ); sendSeq |= (data[offset++] &lt;&lt; 16); sendSeq |= (data[offset++] &lt;&lt; 24); return sendSeq &gt;= 1 &amp;&amp; sendSeq &lt;= 3; &#125; /** * 校验确认数据 * 协议：$ + packType(1) + sendSeq(4) + deviceIP(n&lt;=15) * packType - 报文类型 * sendSeq - 发送序列 * deviceIP - 设备IP，仅确认时携带 */ private boolean verifyCheckData(DatagramPacket pack) &#123; if (pack.getLength() &lt; 6) &#123; return false; &#125; byte[] data = pack.getData(); int offset = pack.getOffset(); int sendSeq; if (data[offset++] != '$' || data[offset++] != PACKET_TYPE_FIND_DEVICE_CHK_12) &#123; return false; &#125; sendSeq = data[offset++] &amp; 0xFF; sendSeq |= (data[offset++] &lt;&lt; 8 ); sendSeq |= (data[offset++] &lt;&lt; 16); sendSeq |= (data[offset++] &lt;&lt; 24); if (sendSeq &lt; 1 || sendSeq &gt; RESPONSE_DEVICE_MAX) &#123; return false; &#125; String ip = new String(data, offset, pack.getLength() - offset, Charset.forName("UTF-8")); Log.i(TAG, "@@@zjun: ip from host=" + ip); return ip.equals(getOwnWifiIP()); &#125; /** * 获取本机在Wifi中的IP */ private String getOwnWifiIP() &#123; WifiManager wm = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE); if (!wm.isWifiEnabled()) &#123; return ""; &#125; // 需加权限：android.permission.ACCESS_WIFI_STATE WifiInfo wifiInfo = wm.getConnectionInfo(); int ipInt = wifiInfo.getIpAddress(); String ipAddr = int2Ip(ipInt); Log.i(TAG, "@@@zjun: 本机IP=" + ipAddr); return int2Ip(ipInt); &#125; /** * 把int表示的ip转换成字符串ip */ private String int2Ip(int i) &#123; return String.format("%d.%d.%d.%d", i &amp; 0xFF, (i &gt;&gt; 8) &amp; 0xFF, (i &gt;&gt; 16) &amp; 0xFF, (i &gt;&gt; 24) &amp; 0xFF); &#125;&#125; 设备——demo核心代码： 12345678private void initData() &#123; new DeviceWaitingSearch(this, "日灯光", "客厅")&#123; @Override public void onDeviceSearched(InetSocketAddress socketAddr) &#123; pushMsgToMain("已上线，搜索主机：" + socketAddr.getAddress().getHostAddress() + ":" + socketAddr.getPort()); &#125; &#125;.start();&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>socket</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP基础]]></title>
    <url>%2F2017%2F10%2F19%2FUDP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[原文地址 UDP发送数据，不管对方有没有收到，也就不需要把两个主机先连接好再通信。所以，UDP一般不用做自由通信用。关于UDP网络编程，主要区分TCP，注意以下几点： 网络连接属于耗时，必须在子线程中执行。网络的连接主要在socket的send()和receive(); 服务器与客户端的套接字都是DatagramSocket; 接收时监听的端口与DatagramSocket直接绑定，此绑定的端口也可直接用于发送数据。 目标主机及端口信息都是封装在数据报DatagramPacket中。本机的发送端口若未绑定，则是由系统分配。 是数据报模式(TCP是流模式)，数据发送与接收都是使用数据报，一次性发送完毕，接收也是一次性必须全部接收完毕，所以数据缓冲区要足够大，否则会导致数据丢失了； 能在局域网内组播和广播。 UDP服务器主要API: DatagramSocket: new DatagramSocket(int port) — 创建监听端口为port的套接字 setSoTimeout(int timeout) — 设置接收信息的超时时间。不设置，则一直阻塞 receive(Datagrampacket packet) — 用数据报packet接收数据，阻塞试。未设置超时时间，一直阻塞，设置了没接收到数据会抛SocketTimeoutException close() — 关闭 DatagramPacket: new DataframePacket(byte[] data,int length) — 创建一个data为数据缓冲区，数据最大长度(≤ data.length) 为length的数据报。有效数据缓冲区应该足够大来装下对方送来过来的全部数据，否则超过缓冲区的数据将丢失。 getLength() — 获取接收到的数据的有效长度 getData() — 获取数据报中的数据，就是上面的data getAddress().getHostAddress() — 获取数据报中的主机IP地址。发送和接收获取的，都是对方IP getPort() — 获取数据报中的端口。发送和接收获取的，都是对方IP 1234567891011121314151617181920212223242526272829303132333435363738//服务器端代码 private boolean mIsServerOn; private void turnOnUdpServer() &#123; final int port = 8000; new Thread( new Runnable() &#123; @Override public void run() &#123; DatagramSocket socket = null; try &#123; //1、创建套接字 socket = new DatagramSocket(port); //2、创建数据报 byte[] data = new byte[1024]; DatagramPacket packet = new DatagramPacket(data, data.length); //3、一直监听端口，接收数据报 mIsServerOn = true; while (mIsServerOn) &#123; socket.receive(packet); String rece = new String(data, 0, packet.getLength(), Charset.forName("UTF-8")); //pushMsgToMain(rece);//推送信息到主线程 Log.i(TAG, "接收到的信息：" + rece); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != socket) &#123; socket.close(); socket = null; &#125; &#125; &#125; &#125; ).start(); &#125; UDP客户端主要API(与服务器一样的，就不介绍了)： DatagramSocket: new DatagramSocket() — 创建套接字，端口为系统给定 getLocalPort() — 获取套接字绑定在本机的端口 getLocalAddress().getHostAddress() — 获取本机IP地址。需要connect()连接成功后才能获取到 bind(SocketAddress addr) — 将套接字连接到远程套接字地址(IP地址 + 端口号)。连接后，在数据报中客户不指定目标主机IP和端口了，如果要指定，必须与connect中的一样 isConencted() — 用connect()连接成功后，返回true DatagramPacket: new DatagramPacket(byte[] data,int length,SocketAddress sockAddr) — 创建数据报，并指定目标主机的套接字地址 new DatagramPacket(byte[] data,int length,InetAddress host,int port) – 创建数据报，并指定目标主机的网络地址和端口号 InetAddress: InetAddress.getByName(String host) — 创建IP地址为host的网络地址对象，封装IP地址 SocketAddress: new InetSocketAddress(String host,int port) — 创建IP地址为host,端口号为port的套接字地址对象，封装了IP地址和端口号。1234567891011121314151617181920212223242526272829303132333435363738private void turnOnUdpClient() &#123; final String hostIp = "192.168.8.101"; final int port = 8000; new Thread(new Runnable() &#123; @Override public void run() &#123; DatagramSocket socket = null; //1、创建套接字 try &#123; socket = new DatagramSocket(port); //2、创建host的地址包装实例 SocketAddress socketAddress = new InetSocketAddress(hostIp,port); //3、创建数据报。包含要发送的数据、与目标主机地址 byte[] data = "Hello,I am Client".getBytes(Charset.forName("UTF-8")); DatagramPacket packet = new DatagramPacket(data,data.length,socketAddress); //4、发送数据 socket.send(packet); //再次发送数据 packet.setData("Second information from client".getBytes(Charset.forName("UTF-8"))); socket.send(packet); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (null !=socket)&#123; socket.close(); &#125; &#125; &#125; &#125;).start();&#125; UDP广播广播就是发送信息给网络中内所有的计算机设备广播的实现方法：在发送消息时，把主机IP地址修改为广播地址即可。 广播地址，一般有两种： UDP有固定的广播地址：255.255.255.255 另外，使用TCP/IP协议的网络，主机标识段host ID全为1的IP地址也为广播地址。如：我的局域网网段为192.168.1.0(255.255.255.0),广播地址为: 192.168.1.255。 UDP组播(多播)组播，是让同一组的计算机设备都接收到信息。让具有相同需求功能的计算机设备，加入到同一组中，然后任一计算机发送组播信息，其他成员都能接收到。 发送和接收信息，都必须使用组播地址（224.0.0.0~239.255.255.255）。计算机要加入该组，就必须加入该多播组地址。 具有以下特点： 它与广播都是UDP独有的； 只有相同组的计算机设备才能接收到; 发送和接收的套接字都是MulticastSocket。 主要API（基本使用方法与DatagramSocket是一样的，就多了几个方法）： MulticastSocket： new MulticastSocket() —— 创建多播套接字，端口是系统给定的 new MulticastSocket(int port) —— 创建绑定端口号到port的多播套接字 new MulticastSocket(SocketAddress localAddr) —— 创建绑定到套接字地址localAddr的多播套接字 setTimeToLive(int ttl) —— 设置time to live为ttl，默认为1。time to live可简单理解为可到达路由器的个数（详见下面总结） joinGroup(InetAddress groupAddr) —— 加入到组播地址groupAddr leaveGroup(InetAddress groupAddr) —— 离开组播地址groupAddr setSoTimeout(int timeout) —— 设置接收信息的超时时间 send(DatagramPacket pack) —— 发送数据报 receive(DatagramPacket pack) —— 接收数据报 下面是发送和接收的demo代码。 发送：12345678910111213141516171819202122232425262728293031323334353637383940private void sendUdpMulticast() &#123; final String groupIP = "224.1.1.1"; final int port = 8000; new Thread(new Runnable() &#123; @Override public void run() &#123; MulticastSocket mcSocket = null; try &#123; // 1、创建组播套接字 mcSocket = new MulticastSocket(); // 设置TTL为1，套接字发送的范围为本地网络。默认也为1 mcSocket.setTimeToLive(1); // 2、创建组播网络地址，并判断 InetAddress groupAddr = InetAddress.getByName(groupIP); if (!groupAddr.isMulticastAddress()) &#123; pushMsgToMain(UDP_HANDLER_MESSAGE_TOAST, "IP地址不是组播地址（224.0.0.0~239.255.255.255）"); return; &#125; // 3、让套接字加入到组播中 mcSocket.joinGroup(groupAddr); // 4、创建数据报 byte[] data = ("Hi, I am Multicast of UDP".getBytes(Charset.forName("UTF-8"))); DatagramPacket pack = new DatagramPacket(data, data.length, groupAddr, port); // 5、发送信息 mcSocket.send(pack); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != mcSocket) &#123; mcSocket.close(); &#125; &#125; &#125; &#125;).start();&#125; 接收: 1234567891011121314151617181920212223242526272829303132333435363738394041424344private boolean mIsUdpMulticastOn;private void receiveUdpMulticast() &#123; final String groupIP = "224.1.1.1"; final int port = 8000; new Thread()&#123; @Override public void run() &#123; MulticastSocket mcSocket = null; try &#123; // 1、创建多播套接字 mcSocket = new MulticastSocket(port); // 2、创建多播组地址，并校验 InetAddress groupAddr = InetAddress.getByName(groupIP); if (!groupAddr.isMulticastAddress()) &#123; pushMsgToMain(UDP_HANDLER_MESSAGE_TOAST, "IP地址不是组播地址（224.0.0.0~239.255.255.255）"); return; &#125; // 3、把套接字加入到多播组中 mcSocket.joinGroup(groupAddr); // 4、创建数据报 byte[] data = new byte[1024]; DatagramPacket pack = new DatagramPacket(data, data.length); // 5、接收信息。循环接收信息，并把接收到的数据交给主线程处理 mIsUdpMulticastOn = true; while (mIsUdpMulticastOn) &#123; mcSocket.receive(pack); String rece = new String(data, pack.getOffset(), pack.getLength()); pushMsgToMain(UDP_HANDLER_MESSAGE_DATA, rece); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != mcSocket) &#123; mcSocket.close(); &#125; &#125; &#125; &#125;.start();&#125; UDP总结UDP的数据data最大是多少经过测试，DatagramPacket中的数据data最大是65507，超过则会在发送的时候报错：1Exception:sendto failed: EMSGSIZE (Message too long) 接收的data大小，可以超65536（2^16），但一般也没必要超过发送的最大值65507，最多65536。 报头又包括IP包头（20字节）和UDP报文头（8字节 所以，UDP数据的最大值 = 65535 - 20 - 8 = 65507 bind 与connect 的区别1. bind(SocketAddress addr)将套接字绑定到特定的地址和端口，本地的绑定。 使用示例： 123DatagramSocket s = new DatagramSocket(null);SocketAddress local = new InetSocketAddress(8888);s.bind(local); 与此句代码等效：1DatagramSocket s = new DatagramSocket(8888); 使用说明： DatagramSocket如果绑定了端口，则不能再绑定，否则抛异常。 如：DatagramSocket s = new DatagramSocket(8000); s.bind(local); 一般情况下，去绑定地址（就算与本机地址一样）也将报错。 如：SocketAddress local = new InetSocketAddress(&quot;192.168.1.222&quot;, 8888); s.bind(local); 2、connect(SocketAddress addr)将套接字连接到远程套接字地址（IP地址+端口号），连接对方。使用示例： 123456socket = new DatagramSocket(8888);SocketAddress local = new InetSocketAddress("192.168.1.145", 8000);socket.connect(local);byte[] data = "Hello, I am Client".getBytes(Charset.forName("UTF-8"));DatagramPacket packet = new DatagramPacket(data, data.length);socket.send(packet); 与此代码等效： 12345socket = new DatagramSocket(8888);SocketAddress socketAddr = new InetSocketAddress(hostIP, port);byte[] data = "Hello, I am Client".getBytes(Charset.forName("UTF-8"));DatagramPacket packet = new DatagramPacket(data, data.length, socketAddr);socket.send(packet); 简单理解TTLTTL（Time To Live）的作用是限制IP数据包在计算机网络中的存在的时间。TTL的最大值是255，TTL的一个推荐值是64。 虽然TTL从字面上翻译，是可以存活的时间，但实际上TTL是IP数据包在计算机网络中可以转发的最大跳数。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL=0的IP包并向IP包的发送者发送 ICMP time exceeded消息。 所以，TTL可以简单的理解为能达到路由器的个数。]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>socket</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell 命令]]></title>
    <url>%2F2017%2F09%2F19%2Fshell-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用shell ls 列出所有目录 -l参数 详细信息 ps 查看当前系统中运行的进程 reboot 设备重启 常用adb命令原文地址ADB Shell学习 ADB Debugging命令adb启动activity： adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}adb启动service： adb shell am startservice -n ｛包(package)名｝/｛包名｝.{服务(service)名称}adb发送broadcast： adb shell am broadcast -a &lt;广播动作&gt; 如：发送一个网络变化的广播 1am broadcast -a android.net.conn.CONNECTIVITY_CHANGE adb devices列出连接的设备 adb kill-server终止adb服务进程 如果服务在运行则终止 adb connect网络连接命令123adb connect &lt;host&gt; [:&lt;port&gt;]//比如adb connect 192.168.1.1 adb disconnect断开通过TCP/IP连接的设备 App包的管理命令adb install安装Android应用到设备，需要指定需要安装的 .apk 文件的全路径 adb install [option] 例如1adb install -l C:\\text.apk 参数 含义 -l 给apk上锁，发布 apk 到 android market上时，可以设置相关标志位来保护你的 app -t 允许测试 -s 在sdcard上安装 -r 重新安装apk -d 允许低版本代码 -g 授予所有运行权限 adb uninstall从设备中卸载app adb uninstall 包名 1adb uninstall com.test.app 快速删除目录(文件夹)如果程序在sd卡上创建了目录MyApp,在该目录中有数据库和一些其他文件,在将程序发布到手机上测试时, 需要删除原来创建的目录再重新创建.这时只需要执行以下命令: 123adb shellcd /mnt/sdcardrm -r MyApp 这样的话就不必再在文件浏览器中寻找这个目录并删除它 . adb shell pm list packages打印出设备安装的所有包信息，可选参数用于过滤要显示的包名 adb shell pm list packages [options] 1adb shell pm list packages 参数 含义 -f 查看相关的文件 -d 只显示禁用的packages -e 只显示可用的packages -s 只显示系统级别的packages -3 只显示第三方的packages(非系统) -i 查看安装器(比如google play) -u 包括卸载的packages adb shell pm path打印制定APK的路径 adb shell pm path \ 1234adb shell pm path com.android.phone//返回结果package:/system/priv-app/TeleService/TeleService.apk adb shell pm clear删除所有有关的数据 12345adb shell pm clearadb shell pm clear com.test.abc//返回结果clearing app data, cache 文件管理adb pull [local]adb push 从电脑上传指定文件到设备 截屏adb shell screencap adb shell screencap \ adb shell screencap /sdcard/screen.png adb pull /sdcard/screen.png adb shell screenrecord 录制屏幕，android4.4(api 19)以上可用adb shell screenrecord [options] \12345adb shell screenrecord /sdcard/demo.mp4//(按 Ctrl-C停止录屏)//从设备下载该录像文件adb pull /sdcard/demo.mp4 提示：按Ctrl-C停止录屏，默认3分钟自动停止，也可以添加参数 –time-limit 设置录制时间. 设置视频大小：1280*720. 默认为设备分辨率，最好使用设备支持的分辨率adb shell screenrecord --size &lt;WIDTH*HEIGHT&gt; 设置视频的bit比，默认4Mbps，可以增加比例提升视频清晰度，但是也会增大文件大小, 例子: bit比为5Mbps， 1adb shell screenrecord --bit-rate 5000000 /sdcard/demo.mp4]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Framework</tag>
        <tag>[object Object]</tag>
        <tag>Android 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 四、背压]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava-%E5%9B%9B%E3%80%81%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[Backpressure(背压)原文地址:给初学者的RxJava2.0教程(四) 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。 背压是流速控制的一种策略。 比如情形一： 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; //无限循环发事件 emitter.onNext(i); &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); Log.d(TAG, "" + integer); &#125; &#125;); 在上述代码中，Observable发射速度远远大于Observer的处理速度，导致OOM出现 Flowable 和 Subscriber所以在RxJava2.0 中，出现了两种观察者模式： Observable ( 被观察者 ) / Observer ( 观察者 ) Flowable （被观察者）/ Subscriber （观察者） 在 RxJava 2.x 中，Observable 用于订阅 Observer，不再支持背压（1.x 中可以使用背压策略），而 Flowable 用于订阅 Subscriber， 是支持背压（Backpressure）的。 之前我们所的上游和下游分别是Observable和Observer, 这次不一样的是上游变成了Flowable, 下游变成了Subscriber, 但是水管之间的连接还是通过subscribe(), 我们来看看最基本的用法吧: 12345678910111213141516171819202122232425262728293031323334353637383940Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(Long.MAX_VALUE); //注意这句代码 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "onNext: " + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;; upstream.subscribe(downstream); 除了类名不同外，还要注意： Flowable.create()方法添加了一个参数 BackpressureStrategy.ERROR 这种方式会在出现上下游流速不均衡的时候直接抛出一个异常,这个异常就是著名的MissingBackpressureException. Subscriber的onSubscribe()方法中，调用了s.request(Long.MAX_VALUE) 告知上游的下游的处理能力 响应式拉取（reactive pull）在RxJava的观察者模型中，被观察者是主动的推送数据给观察者，观察者是被动接收的。而响应式拉取则反过来，观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据。背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。如果上游和下游,同在一个线程中，下游没有调用调用了s.request(Long.MAX_VALUE)方法，上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅, 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因此只能抛个异常来提醒我们. 那如何解决这种情况呢, 很简单啦, 下游直接调用request(Long.MAX_VALUE)就行了, 或者根据上游发送事件的数量来request就行了, 比如这里request(3)就可以了. 上下游没有工作在同一个线程时, 上游却正确的发送了所有的事件呢? 这是因为在Flowable里默认有一个大小为128的水缸, 当上下游工作在不同的线程中时, 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request, 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游. 除了BackpressureStrategy.ERROR还有另外BackpressureStrategy.BUFFER、BackpressureStrategy.DROP和BackpressureStrategy.LATEST BackpressureStrategy.BUFFER 给缓存区换一个大的缓存，但是和Observable 一样，如果下游处理不过来，一样会出现OOM BackpressureStrategy.DROP FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(128)的时候,下游便会处理掉这128个事件, 那么上游水缸中又会重新装进新的128个事件, 以此类推 BackpressureStrategy.LATEST 和BackpressureStrategy.DROP类似，保存128个事件，多余的丢弃，但是能获得最后一个事件 有些FLowable并不是我自己创建的, 该怎么办呢? 比如RxJava中的interval操作符，RxJava给我们提供了其他的方法: onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest() 比如: 12345678910111213141516171819202122232425262728293031Flowable.interval(1, TimeUnit.MICROSECONDS) .onBackpressureDrop() //加上背压策略 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); mSubscription = s; s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "onNext: " + aLong); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 三、操作符]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[原文地址:给初学者的RxJava2.0教程(三) RxJava事件传递过程中的那些鬼斧神工的操作Mapmap是RxJava中最简单的一个变换操作符了, 它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化. 用事件图表示如下: 图中map中的函数作用是将圆形事件转换为矩形事件, 从而导致下游接收到的事件就变为了矩形.用代码来表示这个例子就是: 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return "This is result " + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 在上游我们发送的是数字类型, 而在下游我们接收的是String类型, 中间起转换作用的就是map操作符, 运行结果为:123D/TAG: This is result 1 D/TAG: This is result 2 D/TAG: This is result 3 FlatMapflatMap是一个非常强大的操作符, 先用一个比较难懂的概念说明一下: FlatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里. 这句话比较难以理解, 我们先通俗易懂的图片来详细的讲解一下, 首先先来看看整体的一个图片: 先看看上游, 上游发送了三个事件, 分别是1,2,3, 注意它们的颜色. 中间flatMap的作用是将圆形的事件转换为一个发送矩形事件和三角形事件的新的上游Observable. 还是不能理解? 别急, 再来看看分解动作: 上游每发送一个事件, flatMap都将创建一个新的水管, 然后发送转换之后的新的事件, 下游接收到的就是这些新的水管发送的数据. 这里需要注意的是, flatMap并不保证事件的顺序, 也就是图中所看到的, 并不是事件1就在事件2的前面. 如果需要保证顺序则需要使用concatMap. map与flatMap的区别map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。所以 flatMap 和 map 有两个区别： 经过 Observable 的转换，相当于重新开了一个异步的流； item 被分散了，个数发生了变化。 zipZip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。 从这个图中可以看见, 这次上游和以往不同的是, 我们有两根水管了. 其中一根水管负责发送圆形事件 , 另外一根水管负责发送三角形事件 , 通过Zip操作符, 使得圆形事件 和三角形事件 合并为了一个矩形事件 . 下面我们再来看看分解动作： 通过分解动作我们可以看出: 组合的过程是分别从 两根水管里各取出一个事件 来进行组合, 并且一个事件只能被使用一次, 组合的顺序是严格按照事件发送的顺利 来进行的, 也就是说不会出现圆形1 事件和三角形B 事件进行合并, 也不可能出现圆形2 和三角形A 进行合并的情况. 最终下游收到的事件数量 是和上游中发送事件最少的那一根水管的事件数量 相同. 这个也很好理解, 因为是从每一根水管 里取一个事件来进行合并, 最少的 那个肯定就最先取完 , 这个时候其他的水管尽管还有事件 , 但是已经没有足够的事件来组合了, 因此下游就不会收到剩余的事件了. 分析了大概的原理, 我们还是劳逸结合, 先来看看实际中的代码怎么写吧: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit 4"); emitter.onNext(4); Log.d(TAG, "emit complete1"); emitter.onComplete(); &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, "emit A"); emitter.onNext("A"); Log.d(TAG, "emit B"); emitter.onNext("B"); Log.d(TAG, "emit C"); emitter.onNext("C"); Log.d(TAG, "emit complete2"); emitter.onComplete(); &#125; &#125;); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "onSubscribe"); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, "onNext: " + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "onError"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 我们分别创建了两个上游水管, 一个发送1,2,3,4,Complete, 另一个发送A,B,C,Complete, 接着用Zip把发出的事件组合, 来看看运行结果吧: 1234567891011121314D/TAG: onSubscribe D/TAG: emit 1 D/TAG: emit 2 D/TAG: emit 3 D/TAG: emit 4 D/TAG: emit complete1 D/TAG: emit A D/TAG: onNext: 1A D/TAG: emit B D/TAG: onNext: 2B D/TAG: emit C D/TAG: onNext: 3C D/TAG: emit complete2 D/TAG: onComplete 学习了Zip的基本用法, 那么它在Android有什么用呢, 其实很多场景都可以用到Zip. 举个例子. 比如一个界面需要展示用户的一些信息, 而这些信息分别要从两个服务器接口中获取, 而只有当两个都获取到了之后才能进行展示, 这个时候就可以用Zip了 更多操作符可以查看：Rxjava操作符大全 常用操作符from 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。 1234567Observable.from(futrue) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; &#125; &#125;); just 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。 empty 创建一个什么都不做直接通知完成的Observable 1Observable observable1=Observable.empty();//直接调用onCompleted。 error 创建一个什么都不做直接通知错误的Observable 1Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常 never 创建一个什么都不做的Observable 1Observable observable3=Observable.never();//啥都不做 timer 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作1234567Observable.timer(1000,TimeUnit.MILLISECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.d("JG",aLong.toString()); // 0 &#125; &#125;); interval创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。 12345678Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; //每隔1秒发送数据项，从0开始计数 //0,1,2,3.... &#125; &#125;); range创建一个发射指定范围的整数序列的Observable 123456Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.d("TAG",integer.toString());// 2,3,4,5,6 从2开始发射5个数据 &#125; &#125;); defer只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。1234567891011Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just("hello"); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d("JG",s); &#125; &#125;); 合并操作concat按顺序连接多个Observables。 需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。 12345Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);Observable&lt;Integer&gt; observable2=Observable.just(4,5,6);Observable.concat(observable1,observable2) .subscribe(item-&gt;Log.d("JG",item.toString()));//1,2,3,4,4,5,6 startWith在数据序列的开头增加一项数据。startWith的内部也是调用了concat123Observable.just(1,2,3,4,5) .startWith(6,7,8) .subscribe(item-&gt;Log.d("JG",item.toString()));//6,7,8,1,2,3,4,5 merge操作符 可用于两个任务并发进行，全部处理完毕之后在更新数据 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。 1Observable.merge(obs1,obs2)。。。。 过滤操作filter 过滤把不符合条件的过滤掉,留下符合条件的 1234567.filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; //包含a的留下 return s.contains("a"); &#125;&#125;) ofType过滤指定类型的数据，与filter类似，123Observable.just(1,2,"3") .ofType(Integer.class) .subscribe(item -&gt; Log.d("JG",item.toString())); take提取操作符只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。123Observable.just(3,4,5,6) .take(3)//发射前三个数据项 .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据 takeLast 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。 takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。 123Observable.just(3,4,5,6) .takeLast(3) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4,5,6 first/firstOrDefault只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。1234567891011Observable.just(3,4,5,6) .first() .subscribe(integer -&gt; Log.d("JG",integer.toString()));//3 Observable.just(3,4,5,6) .first(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer&gt;3; &#125; &#125;) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4 last/lastOrDefault只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。 skip跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。 123Observable.just(3,4,5,6) .skip(1) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4,5,6 skipLast跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。 distinct过滤重复数据，内部通过OperatorDistinct实现。123Observable.just(3,4,5,6,3,3,4,9) .distinct() .subscribe(item-&gt;Log.d("JG",item.toString())); //3,4,5,6,9 Map一种转换操作符，在call方法中，将T类型转换成E类型返回。 123456 .map(new Func1&lt;T, E&gt;() &#123; @Override public E call(T) &#123; return E; &#125;&#125; flatmap操作将每个Observable产生的事件里的信息再包装成新的Observable传递出来 123456789101112131415Observable.from(getSchoolClass()) .flatMap(new Func1&lt;SchoolClass, Observable&lt;Student&gt;&gt;() &#123; @Override public Observable&lt;Student&gt; call(SchoolClass schoolClass) &#123; //将Student列表使用from方法一个一个发出去 return Observable.from(schoolClass.getStudents()); &#125; &#125;) .subscribe(new Action1&lt;Student&gt;() &#123; @Override public void call(Student student) &#123; mText.append("打印单个学生信息：\n"); mText.append("name:"+student.name+" age: "+student.age+"\n"); &#125; &#125;); map与flatMap的区别 map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走 flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。 所以 flatMap 和 map 有两个区别： 经过 Observable 的转换，相当于重新开了一个异步的流； item 被分散了，个数发生了变化。 两个被观察者都调用onCompleted后，才会执行观察者的onCompleted toSortedList排序操作符1234567891011121314Observable.from(words) .toSortedList() .flatMap(new Func1&lt;List&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(List&lt;Integer&gt; strings) &#123; return Observable.from(strings); &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer strings) &#123; mText.append(strings+"\n"); &#125; &#125;); doOnNext允许我们在每次输出一个元素之前做一些额外的事情(其实就是在onNext里调用的) 1234567.doOnNext(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; //onNext之前 输出一下 System.out.println("doOnNext:"+s); &#125;&#125;)]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 二、线程调度]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[原文地址：给初学者的RxJava2.0教程(二) 还是以之前的例子, 两根水管: 正常情况下, 上游和下游是工作在同一个线程中的, 也就是说上游在哪个线程发事件, 下游就在哪个线程接收事件. 比如我们在onCreate中打出当前线程的名字: 123456@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, Thread.currentThread().getName()); &#125; 结果:1main 回到RxJava中, 当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件. 当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件, 来看段代码: 123456789101112131415161718192021222324@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "Observable thread is : " + Thread.currentThread().getName()); Log.d(TAG, "emit 1"); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "Observer thread is :" + Thread.currentThread().getName()); Log.d(TAG, "onNext: " + integer); &#125; &#125;; observable.subscribe(consumer); &#125; 在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程, 运行结果为: 1234D/TAG: Observable thread is : mainD/TAG: emit 1 D/TAG: Observer thread is :main D/TAG: onNext: 1 在RxJava中，主要记住两行代码 12.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) 简单的来说 subscribeOn() 指定的是上游发送事件的线程, observeOn()指定的是下游接收事件的线程. 多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有 第一次 的有效, 其余的会被忽略. 多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次. 在RxJava中, 已经内置了很多线程选项供我们选择, 例如有 Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作 Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread() 代表一个常规的新线程 AndroidSchedulers.mainThread() 代表Android的主线程 这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 一、基础]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[原文地址:给初学者的RxJava2.0教程 要在Android中使用RxJava2, 先添加Gradle配置: 123compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; 初步认识用两根水管代替观察者和被观察者, 试图用通俗易懂的话把它们的关系解释清楚, 在这里我将从事件流这个角度来说明RxJava的基本工作原理。 先假设有两根水管： 上面一根水管为事件产生的水管，叫它上游吧，下面一根水管为事件接收的水管叫它下游吧。 这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe()，因此这个关系用RxJava来表示就是： 1234567891011121314151617181920212223242526272829303132333435//创建一个上游 Observable： Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;); //创建一个下游 Observer Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;; //建立连接 observable.subscribe(observer); 这个运行的结果就是:12345subscribe123complete 注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件. RxJava引以为傲的链式操作：1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;); ObservableEmitter和Disposable.ObservableEmitter：Emitte是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。 发送事件遵循一定规则 上游可以发送无限个onNext, 下游也可以接收无限个onNext. 当上游发送了一个onComplete后, 上游 onComplete之后的事件将会继续发送, 而下游收到 onComplete事件之后将不再继续接收事件. 当上游发送了一个onError后, 上游 onError之后的事件将继续发送, 而下游收到onError事件之后将不再接收事件. 上游可以不发送onComplete或onError. 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然 注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃. 示意图 只发送onNext事件 next 发送onComplete事件 complete 发送onError事件 error Disposable对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. 注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件. 来看个例子, 我们让上游依次发送1,2,3,complete,4,在下游收到第二个事件之后, 切断水管, 看看运行结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); Log.d(TAG, "emit 4"); emitter.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable mDisposable; private int i; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); mDisposable = d; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "onNext: " + value); i++; if (i == 2) &#123; Log.d(TAG, "dispose"); mDisposable.dispose(); Log.d(TAG, "isDisposed : " + mDisposable.isDisposed()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;); 运行结果为: 12345678910subscribeemit 1onNext: 1emit 2onNext: 2disposeisDisposed : trueemit 3emit completeemit 4 从运行结果我们看到, 在收到onNext 2这个事件后, 切断了水管, 但是上游仍然发送了3, complete, 4这几个事件, 而且上游并没有因为发送了onComplete而停止. 同时可以看到下游的onSubscribe()方法是最先调用的. 那如果有多个Disposable 该怎么办呢, RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可切断所有的水管. 另外, subscribe()有多个重载的方法: 123456public final Disposable subscribe() &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 最后一个带有Observer参数的我们已经使用过了,这里对其他几个方法进行说明. 不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么. 带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写: 1234567891011121314151617181920Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); Log.d(TAG, "emit 4"); emitter.onNext(4); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "onNext: " + integer); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TV 焦点框]]></title>
    <url>%2F2017%2F09%2F17%2FAndroid-TV-%E7%84%A6%E7%82%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[对于TV或者投影设备来说说，各种事件的处理，主要依赖于遥控器，通过焦点框来显示焦点出现的位置 一般可以通过响应事件来切换控件的背景（例：drawable/selector.xml），但是影响用户体验 通过焦点框的动画效果，使用平移动画绘制焦点框的移动轨迹，并且焦点框随着控件的形状而变化。动画最终状态是,焦点框从失去焦点的位置移动到获得焦点的位置,控件放大,焦点框尺寸最后变为放大后的控件尺寸. 设计思路 焦点框位于布局最上层，当控件获取焦点后，焦点框移动到控件上方 获取当前位置及大小 获取获取焦点控件的位置及大小 计算出平移距离及移动后的大小 开启动画，设置动画效果(移动时间及加速效果等) 自定义焦点框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 自定义焦点框 */public class FocusBorderView extends AppCompatButton &#123; private int moveCount;//记录次数，第一次不出现平移动画 public static final int TRAN_DUR_ANIM = 300;//平移时间 private static final int DEFAULT_BACKGROUND_RESOURCE_ID = R.drawable.icon_focus_border; private int fixX = 0;//x轴偏移量 private int fixY = 0;//y轴偏移量 public FocusBorderView(Context context) &#123; this(context, null); &#125; public FocusBorderView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public FocusBorderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FocusBorderView, defStyle, 0); setBackgroundResource(typedArray.getResourceId(R.styleable.FocusBorderView_focus_border_background, DEFAULT_BACKGROUND_RESOURCE_ID)); typedArray.recycle(); setFocusable(false); setClickable(false); &#125; public void runTranslateAnimation(View toView) &#123; runTranslateAnimation(toView, 1.0F, 1.0F); &#125; public void runTranslateAnimation(View toView, final float scaleX, final float scaleY) &#123; if (toView instanceof AbsListView) &#123; AbsListView absListView = (AbsListView) toView; absListView.setOnItemSelectedListener(new OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; runTranslateAnimation(view, scaleX, scaleY); &#125; public void onNothingSelected(AdapterView&lt;?&gt; parent) &#123; &#125; &#125;); toView = absListView.getSelectedView(); &#125; Rect fromRect = findLocationWithView(this); if (toView == null) &#123; return; &#125; Rect toRect = findLocationWithView(toView); int x = toRect.left - fromRect.left; int y = toRect.top - fromRect.top; int width = (int) (toView.getWidth() * scaleX); int height = (int) (toView.getHeight() * scaleY); int deltaX = (int) ((toView.getWidth() * Math.abs(scaleX - 1)) / 2.0f); int deltaY = (int) ((toView.getHeight() * Math.abs(scaleY - 1)) / 2.0f); x += fixX; y += fixY; flyWhiteBorder(width, height, x - deltaX, y - deltaY); &#125; /** * 焦点框飞动、移动、变大 * * @param width 框的宽 * @param height 框的高 * @param x x坐标偏移量，相对于初始的框的中心点 * @param y y坐标偏移量，相对于初始的框的中心点 */ @SuppressLint("NewApi") private void flyWhiteBorder(int width, int height, float x, float y) &#123; AnimatorSet animSet = new AnimatorSet(); animSet.play(ObjectAnimator.ofFloat(this, "x", x)).with(ObjectAnimator.ofFloat(this, "y", y)) .with(ObjectAnimator.ofInt(this, "width", this.getWidth(), width)) .with(ObjectAnimator.ofInt(this, "height", this.getHeight(), height)); animSet.setInterpolator(new DecelerateInterpolator()); animSet.addListener(flyListener); animSet.setDuration(TRAN_DUR_ANIM).start(); &#125; /** * 获取View的位置 * * @param view 获取的控件 * @return 位置 */ public Rect findLocationWithView(View view) &#123; ViewGroup root = (ViewGroup) this.getParent(); Rect rect = new Rect(); view.getDrawingRect(rect); root.offsetDescendantRectToMyCoords(view, rect); return rect; &#125; private Animator.AnimatorListener flyListener = new Animator.AnimatorListener() &#123; public void onAnimationCancel(Animator arg0) &#123; &#125; public void onAnimationEnd(Animator arg0) &#123; moveCount++; setVisibility(View.VISIBLE); &#125; public void onAnimationRepeat(Animator arg0) &#123; &#125; public void onAnimationStart(Animator arg0) &#123; if (moveCount != 0 &amp;&amp; getVisibility() != View.VISIBLE) &#123; setVisibility(View.VISIBLE); &#125; &#125; &#125;; public int getFixX() &#123; return fixX; &#125; public void setFixX(int fixX) &#123; this.fixX = fixX; &#125; public int getFixY() &#123; return fixY; &#125; public void setFixY(int fixY) &#123; this.fixY = fixY; &#125;``` ### 布局文件``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/root" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="cc.myandroid.focusborderviewdemo.MainActivity"&gt; &lt;GridLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:columnCount="4"&gt; &lt;TextView android:id="@+id/view_1" style="@style/ItemStyle" android:background="@color/color_menu_item_1" android:text="view1" /&gt; &lt;TextView android:id="@+id/view_2" style="@style/ItemStyle" android:background="@color/color_menu_item_2" android:text="view2" /&gt; &lt;TextView android:id="@+id/view_3" style="@style/ItemStyle" android:background="@color/color_menu_item_3" android:text="view3" /&gt; &lt;TextView android:id="@+id/view_4" style="@style/ItemStyle" android:background="@color/color_menu_item_4" android:text="view4" /&gt; &lt;TextView android:id="@+id/view_5" style="@style/ItemStyle" android:background="@color/color_menu_item_5" android:text="view5" /&gt; &lt;TextView android:id="@+id/view_6" style="@style/ItemStyle" android:background="@color/color_menu_item_6" android:text="view6" /&gt; &lt;TextView android:id="@+id/view_7" style="@style/ItemStyle" android:background="@color/color_menu_item_7" android:text="view7" /&gt; &lt;TextView android:id="@+id/view_8" style="@style/ItemStyle" android:background="@color/color_menu_item_8" android:text="view8" /&gt; &lt;/GridLayout&gt; &lt;cc.myandroid.focusborderviewdemo.FocusBorderView android:id="@+id/focus_border_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:focusable="false" android:visibility="invisible" /&gt;&lt;/FrameLayout&gt; Activity1234567891011121314151617181920212223import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.ViewTreeObserver;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity implements ViewTreeObserver.OnGlobalFocusChangeListener&#123; private FocusBorderView focusBorderView; private FrameLayout root; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); focusBorderView = (FocusBorderView) findViewById(R.id.focus_border_view); root = (FrameLayout) findViewById(R.id.root); root.getViewTreeObserver().addOnGlobalFocusChangeListener(this); &#125; @Override public void onGlobalFocusChanged(View oldFocus, View newFocus) &#123; focusBorderView.runTranslateAnimation(newFocus,1.2f,1.2f); &#125;&#125; 主要在根布局中添加监听，不用对每个控件单独设置监听 了解ViewTreeObserver ：解析 ViewTreeObserver 源码，体会观察者模式、Android消息传递（上） 在runTranslateAnimation方法中，可以根据获取焦点控件不同，设置不同的缩放值 文章博客地址 github地址]]></content>
      <categories>
        <category>Android</category>
        <category>Android TV开发笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android TV</tag>
      </tags>
  </entry>
</search>
