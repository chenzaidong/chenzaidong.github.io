<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell 命令]]></title>
    <url>%2F2017%2F09%2F19%2Fshell-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用shell ls 列出所有目录 -l参数 详细信息 ps 查看当前系统中运行的进程 reboot 设备重启 常用adb命令原文地址ADB Shell学习 ADB Debugging命令adb启动activity： adb shell am start -n ｛包(package)名｝/｛包名｝.{活动(activity)名称}adb启动service： adb shell am startservice -n ｛包(package)名｝/｛包名｝.{服务(service)名称}adb发送broadcast： adb shell am broadcast -a &lt;广播动作&gt; 如：发送一个网络变化的广播 1am broadcast -a android.net.conn.CONNECTIVITY_CHANGE adb devices列出连接的设备 adb kill-server终止adb服务进程 如果服务在运行则终止 adb connect网络连接命令123adb connect &lt;host&gt; [:&lt;port&gt;]//比如adb connect 192.168.1.1 adb disconnect断开通过TCP/IP连接的设备 App包的管理命令adb install安装Android应用到设备，需要指定需要安装的 .apk 文件的全路径 adb install [option] 例如1adb install -l C:\\text.apk 参数 含义 -l 给apk上锁，发布 apk 到 android market上时，可以设置相关标志位来保护你的 app -t 允许测试 -s 在sdcard上安装 -r 重新安装apk -d 允许低版本代码 -g 授予所有运行权限 adb uninstall从设备中卸载app adb uninstall 包名 1adb uninstall com.test.app 快速删除目录(文件夹)如果程序在sd卡上创建了目录MyApp,在该目录中有数据库和一些其他文件,在将程序发布到手机上测试时, 需要删除原来创建的目录再重新创建.这时只需要执行以下命令: 123adb shellcd /mnt/sdcardrm -r MyApp 这样的话就不必再在文件浏览器中寻找这个目录并删除它 . adb shell pm list packages打印出设备安装的所有包信息，可选参数用于过滤要显示的包名 adb shell pm list packages [options] 1adb shell pm list packages 参数 含义 -f 查看相关的文件 -d 只显示禁用的packages -e 只显示可用的packages -s 只显示系统级别的packages -3 只显示第三方的packages(非系统) -i 查看安装器(比如google play) -u 包括卸载的packages adb shell pm path打印制定APK的路径 adb shell pm path \ 1234adb shell pm path com.android.phone//返回结果package:/system/priv-app/TeleService/TeleService.apk adb shell pm clear删除所有有关的数据 12345adb shell pm clearadb shell pm clear com.test.abc//返回结果clearing app data, cache 文件管理adb pull [local]adb push 从电脑上传指定文件到设备 截屏adb shell screencap adb shell screencap \ adb shell screencap /sdcard/screen.png adb pull /sdcard/screen.png adb shell screenrecord 录制屏幕，android4.4(api 19)以上可用adb shell screenrecord [options] \12345adb shell screenrecord /sdcard/demo.mp4//(按 Ctrl-C停止录屏)//从设备下载该录像文件adb pull /sdcard/demo.mp4 提示：按Ctrl-C停止录屏，默认3分钟自动停止，也可以添加参数 –time-limit 设置录制时间. 设置视频大小：1280*720. 默认为设备分辨率，最好使用设备支持的分辨率adb shell screenrecord --size &lt;WIDTH*HEIGHT&gt; 设置视频的bit比，默认4Mbps，可以增加比例提升视频清晰度，但是也会增大文件大小, 例子: bit比为5Mbps， 1adb shell screenrecord --bit-rate 5000000 /sdcard/demo.mp4]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Android Framework</tag>
        <tag>[object Object]</tag>
        <tag>Android 学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 四、背压]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava-%E5%9B%9B%E3%80%81%E8%83%8C%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[Backpressure(背压)原文地址:给初学者的RxJava2.0教程(四) 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。 背压是流速控制的一种策略。 比如情形一： 12345678910111213141516Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; ; i++) &#123; //无限循环发事件 emitter.onNext(i); &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Thread.sleep(2000); Log.d(TAG, "" + integer); &#125; &#125;); 在上述代码中，Observable发射速度远远大于Observer的处理速度，导致OOM出现 Flowable 和 Subscriber所以在RxJava2.0 中，出现了两种观察者模式： Observable ( 被观察者 ) / Observer ( 观察者 ) Flowable （被观察者）/ Subscriber （观察者） 在 RxJava 2.x 中，Observable 用于订阅 Observer，不再支持背压（1.x 中可以使用背压策略），而 Flowable 用于订阅 Subscriber， 是支持背压（Backpressure）的。 之前我们所的上游和下游分别是Observable和Observer, 这次不一样的是上游变成了Flowable, 下游变成了Subscriber, 但是水管之间的连接还是通过subscribe(), 我们来看看最基本的用法吧: 12345678910111213141516171819202122232425262728293031323334353637383940Flowable&lt;Integer&gt; upstream = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; downstream = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); s.request(Long.MAX_VALUE); //注意这句代码 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "onNext: " + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;; upstream.subscribe(downstream); 除了类名不同外，还要注意： Flowable.create()方法添加了一个参数 BackpressureStrategy.ERROR 这种方式会在出现上下游流速不均衡的时候直接抛出一个异常,这个异常就是著名的MissingBackpressureException. Subscriber的onSubscribe()方法中，调用了s.request(Long.MAX_VALUE) 告知上游的下游的处理能力 响应式拉取（reactive pull）在RxJava的观察者模型中，被观察者是主动的推送数据给观察者，观察者是被动接收的。而响应式拉取则反过来，观察者主动从被观察者那里去拉取数据，而被观察者变成被动的等待通知再发送数据。背压策略的一个前提是异步环境，也就是说，被观察者和观察者处在不同的线程环境中。如果上游和下游,同在一个线程中，下游没有调用调用了s.request(Long.MAX_VALUE)方法，上游就认为下游没有处理事件的能力, 而这又是一个同步的订阅, 既然下游处理不了, 那上游不可能一直等待吧, 如果是这样, 万一这两根水管工作在主线程里, 界面不就卡死了吗, 因此只能抛个异常来提醒我们. 那如何解决这种情况呢, 很简单啦, 下游直接调用request(Long.MAX_VALUE)就行了, 或者根据上游发送事件的数量来request就行了, 比如这里request(3)就可以了. 上下游没有工作在同一个线程时, 上游却正确的发送了所有的事件呢? 这是因为在Flowable里默认有一个大小为128的水缸, 当上下游工作在不同的线程中时, 上游就会先把事件发送到这个水缸中, 因此, 下游虽然没有调用request, 但是上游在水缸中保存着这些事件, 只有当下游调用request时, 才从水缸里取出事件发给下游. 除了BackpressureStrategy.ERROR还有另外BackpressureStrategy.BUFFER、BackpressureStrategy.DROP和BackpressureStrategy.LATEST BackpressureStrategy.BUFFER 给缓存区换一个大的缓存，但是和Observable 一样，如果下游处理不过来，一样会出现OOM BackpressureStrategy.DROP FLowable内部的默认的水缸大小为128, 因此, 它刚开始肯定会把0-127这128个事件保存起来, 然后丢弃掉其余的事件, 当我们request(128)的时候,下游便会处理掉这128个事件, 那么上游水缸中又会重新装进新的128个事件, 以此类推 BackpressureStrategy.LATEST 和BackpressureStrategy.DROP类似，保存128个事件，多余的丢弃，但是能获得最后一个事件 有些FLowable并不是我自己创建的, 该怎么办呢? 比如RxJava中的interval操作符，RxJava给我们提供了其他的方法: onBackpressureBuffer() onBackpressureDrop() onBackpressureLatest() 比如: 12345678910111213141516171819202122232425262728293031Flowable.interval(1, TimeUnit.MICROSECONDS) .onBackpressureDrop() //加上背压策略 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, "onSubscribe"); mSubscription = s; s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Long aLong) &#123; Log.d(TAG, "onNext: " + aLong); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, "onError: ", t); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 三、操作符]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[原文地址:给初学者的RxJava2.0教程(三) RxJava事件传递过程中的那些鬼斧神工的操作Mapmap是RxJava中最简单的一个变换操作符了, 它的作用就是对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化. 用事件图表示如下: 图中map中的函数作用是将圆形事件转换为矩形事件, 从而导致下游接收到的事件就变为了矩形.用代码来表示这个例子就是: 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer integer) throws Exception &#123; return "This is result " + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.d(TAG, s); &#125; &#125;); 在上游我们发送的是数字类型, 而在下游我们接收的是String类型, 中间起转换作用的就是map操作符, 运行结果为:123D/TAG: This is result 1 D/TAG: This is result 2 D/TAG: This is result 3 FlatMapflatMap是一个非常强大的操作符, 先用一个比较难懂的概念说明一下: FlatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里. 这句话比较难以理解, 我们先通俗易懂的图片来详细的讲解一下, 首先先来看看整体的一个图片: 先看看上游, 上游发送了三个事件, 分别是1,2,3, 注意它们的颜色. 中间flatMap的作用是将圆形的事件转换为一个发送矩形事件和三角形事件的新的上游Observable. 还是不能理解? 别急, 再来看看分解动作: 上游每发送一个事件, flatMap都将创建一个新的水管, 然后发送转换之后的新的事件, 下游接收到的就是这些新的水管发送的数据. 这里需要注意的是, flatMap并不保证事件的顺序, 也就是图中所看到的, 并不是事件1就在事件2的前面. 如果需要保证顺序则需要使用concatMap. map与flatMap的区别map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。所以 flatMap 和 map 有两个区别： 经过 Observable 的转换，相当于重新开了一个异步的流； item 被分散了，个数发生了变化。 zipZip通过一个函数将多个Observable发送的事件结合到一起，然后发送这些组合到一起的事件. 它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。 从这个图中可以看见, 这次上游和以往不同的是, 我们有两根水管了. 其中一根水管负责发送圆形事件 , 另外一根水管负责发送三角形事件 , 通过Zip操作符, 使得圆形事件 和三角形事件 合并为了一个矩形事件 . 下面我们再来看看分解动作： 通过分解动作我们可以看出: 组合的过程是分别从 两根水管里各取出一个事件 来进行组合, 并且一个事件只能被使用一次, 组合的顺序是严格按照事件发送的顺利 来进行的, 也就是说不会出现圆形1 事件和三角形B 事件进行合并, 也不可能出现圆形2 和三角形A 进行合并的情况. 最终下游收到的事件数量 是和上游中发送事件最少的那一根水管的事件数量 相同. 这个也很好理解, 因为是从每一根水管 里取一个事件来进行合并, 最少的 那个肯定就最先取完 , 这个时候其他的水管尽管还有事件 , 但是已经没有足够的事件来组合了, 因此下游就不会收到剩余的事件了. 分析了大概的原理, 我们还是劳逸结合, 先来看看实际中的代码怎么写吧: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit 4"); emitter.onNext(4); Log.d(TAG, "emit complete1"); emitter.onComplete(); &#125; &#125;); Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; Log.d(TAG, "emit A"); emitter.onNext("A"); Log.d(TAG, "emit B"); emitter.onNext("B"); Log.d(TAG, "emit C"); emitter.onNext("C"); Log.d(TAG, "emit complete2"); emitter.onComplete(); &#125; &#125;); Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123; @Override public String apply(Integer integer, String s) throws Exception &#123; return integer + s; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "onSubscribe"); &#125; @Override public void onNext(String value) &#123; Log.d(TAG, "onNext: " + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "onError"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "onComplete"); &#125; &#125;); 我们分别创建了两个上游水管, 一个发送1,2,3,4,Complete, 另一个发送A,B,C,Complete, 接着用Zip把发出的事件组合, 来看看运行结果吧: 1234567891011121314D/TAG: onSubscribe D/TAG: emit 1 D/TAG: emit 2 D/TAG: emit 3 D/TAG: emit 4 D/TAG: emit complete1 D/TAG: emit A D/TAG: onNext: 1A D/TAG: emit B D/TAG: onNext: 2B D/TAG: emit C D/TAG: onNext: 3C D/TAG: emit complete2 D/TAG: onComplete 学习了Zip的基本用法, 那么它在Android有什么用呢, 其实很多场景都可以用到Zip. 举个例子. 比如一个界面需要展示用户的一些信息, 而这些信息分别要从两个服务器接口中获取, 而只有当两个都获取到了之后才能进行展示, 这个时候就可以用Zip了 更多操作符可以查看：Rxjava操作符大全 常用操作符from 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。 1234567Observable.from(futrue) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; &#125; &#125;); just 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。 empty 创建一个什么都不做直接通知完成的Observable 1Observable observable1=Observable.empty();//直接调用onCompleted。 error 创建一个什么都不做直接通知错误的Observable 1Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常 never 创建一个什么都不做的Observable 1Observable observable3=Observable.never();//啥都不做 timer 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作1234567Observable.timer(1000,TimeUnit.MILLISECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.d("JG",aLong.toString()); // 0 &#125; &#125;); interval创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。 12345678Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; //每隔1秒发送数据项，从0开始计数 //0,1,2,3.... &#125; &#125;); range创建一个发射指定范围的整数序列的Observable 123456Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.d("TAG",integer.toString());// 2,3,4,5,6 从2开始发射5个数据 &#125; &#125;); defer只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。1234567891011Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just("hello"); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d("JG",s); &#125; &#125;); 合并操作concat按顺序连接多个Observables。 需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。 12345Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);Observable&lt;Integer&gt; observable2=Observable.just(4,5,6);Observable.concat(observable1,observable2) .subscribe(item-&gt;Log.d("JG",item.toString()));//1,2,3,4,4,5,6 startWith在数据序列的开头增加一项数据。startWith的内部也是调用了concat123Observable.just(1,2,3,4,5) .startWith(6,7,8) .subscribe(item-&gt;Log.d("JG",item.toString()));//6,7,8,1,2,3,4,5 merge操作符 可用于两个任务并发进行，全部处理完毕之后在更新数据 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。 1Observable.merge(obs1,obs2)。。。。 过滤操作filter 过滤把不符合条件的过滤掉,留下符合条件的 1234567.filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; //包含a的留下 return s.contains("a"); &#125;&#125;) ofType过滤指定类型的数据，与filter类似，123Observable.just(1,2,"3") .ofType(Integer.class) .subscribe(item -&gt; Log.d("JG",item.toString())); take提取操作符只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。123Observable.just(3,4,5,6) .take(3)//发射前三个数据项 .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据 takeLast 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。 takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。 123Observable.just(3,4,5,6) .takeLast(3) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4,5,6 first/firstOrDefault只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。1234567891011Observable.just(3,4,5,6) .first() .subscribe(integer -&gt; Log.d("JG",integer.toString()));//3 Observable.just(3,4,5,6) .first(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer&gt;3; &#125; &#125;) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4 last/lastOrDefault只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。 skip跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。 123Observable.just(3,4,5,6) .skip(1) .subscribe(integer -&gt; Log.d("JG",integer.toString()));//4,5,6 skipLast跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。 distinct过滤重复数据，内部通过OperatorDistinct实现。123Observable.just(3,4,5,6,3,3,4,9) .distinct() .subscribe(item-&gt;Log.d("JG",item.toString())); //3,4,5,6,9 Map一种转换操作符，在call方法中，将T类型转换成E类型返回。 123456 .map(new Func1&lt;T, E&gt;() &#123; @Override public E call(T) &#123; return E; &#125;&#125; flatmap操作将每个Observable产生的事件里的信息再包装成新的Observable传递出来 123456789101112131415Observable.from(getSchoolClass()) .flatMap(new Func1&lt;SchoolClass, Observable&lt;Student&gt;&gt;() &#123; @Override public Observable&lt;Student&gt; call(SchoolClass schoolClass) &#123; //将Student列表使用from方法一个一个发出去 return Observable.from(schoolClass.getStudents()); &#125; &#125;) .subscribe(new Action1&lt;Student&gt;() &#123; @Override public void call(Student student) &#123; mText.append("打印单个学生信息：\n"); mText.append("name:"+student.name+" age: "+student.age+"\n"); &#125; &#125;); map与flatMap的区别 map 是在一个 item 被发射之后，到达 map 处经过转换变成另一个 item ，然后继续往下走 flapMap 是 item 被发射之后，到达 flatMap 处经过转换变成一个 Observable ，而这个 Observable 并不会直接被发射出去，而是会立即被激活，然后把它发射出的每个 item 都传入流中，再继续走下去。 所以 flatMap 和 map 有两个区别： 经过 Observable 的转换，相当于重新开了一个异步的流； item 被分散了，个数发生了变化。 两个被观察者都调用onCompleted后，才会执行观察者的onCompleted toSortedList排序操作符1234567891011121314Observable.from(words) .toSortedList() .flatMap(new Func1&lt;List&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() &#123; @Override public Observable&lt;Integer&gt; call(List&lt;Integer&gt; strings) &#123; return Observable.from(strings); &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer strings) &#123; mText.append(strings+"\n"); &#125; &#125;); doOnNext允许我们在每次输出一个元素之前做一些额外的事情(其实就是在onNext里调用的) 1234567.doOnNext(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; //onNext之前 输出一下 System.out.println("doOnNext:"+s); &#125;&#125;)]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 二、线程调度]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[原文地址：给初学者的RxJava2.0教程(二) 还是以之前的例子, 两根水管: 正常情况下, 上游和下游是工作在同一个线程中的, 也就是说上游在哪个线程发事件, 下游就在哪个线程接收事件. 比如我们在onCreate中打出当前线程的名字: 123456@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG, Thread.currentThread().getName()); &#125; 结果:1main 回到RxJava中, 当我们在主线程中去创建一个上游Observable来发送事件, 则这个上游默认就在主线程发送事件. 当我们在主线程去创建一个下游Observer来接收事件, 则这个下游默认就在主线程中接收事件, 来看段代码: 123456789101112131415161718192021222324@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "Observable thread is : " + Thread.currentThread().getName()); Log.d(TAG, "emit 1"); emitter.onNext(1); &#125; &#125;); Consumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "Observer thread is :" + Thread.currentThread().getName()); Log.d(TAG, "onNext: " + integer); &#125; &#125;; observable.subscribe(consumer); &#125; 在主线程中分别创建上游和下游, 然后将他们连接在一起, 同时分别打印出它们所在的线程, 运行结果为: 1234D/TAG: Observable thread is : mainD/TAG: emit 1 D/TAG: Observer thread is :main D/TAG: onNext: 1 在RxJava中，主要记住两行代码 12.subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) 简单的来说 subscribeOn() 指定的是上游发送事件的线程, observeOn()指定的是下游接收事件的线程. 多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有 第一次 的有效, 其余的会被忽略. 多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次. 在RxJava中, 已经内置了很多线程选项供我们选择, 例如有 Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作 Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread() 代表一个常规的新线程 AndroidSchedulers.mainThread() 代表Android的主线程 这些内置的Scheduler已经足够满足我们开发的需求, 因此我们应该使用内置的这些选项, 在RxJava内部使用的是线程池来维护这些线程, 所有效率也比较高.]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.0 一、基础]]></title>
    <url>%2F2017%2F09%2F19%2FRxJava2-0-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[原文地址:给初学者的RxJava2.0教程 要在Android中使用RxJava2, 先添加Gradle配置: 123compile &apos;io.reactivex.rxjava2:rxjava:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos; 初步认识用两根水管代替观察者和被观察者, 试图用通俗易懂的话把它们的关系解释清楚, 在这里我将从事件流这个角度来说明RxJava的基本工作原理。 先假设有两根水管： 上面一根水管为事件产生的水管，叫它上游吧，下面一根水管为事件接收的水管叫它下游吧。 这里的上游和下游就分别对应着RxJava中的Observable和Observer，它们之间的连接就对应着subscribe()，因此这个关系用RxJava来表示就是： 1234567891011121314151617181920212223242526272829303132333435//创建一个上游 Observable： Observable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;); //创建一个下游 Observer Observer&lt;Integer&gt; observer = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;; //建立连接 observable.subscribe(observer); 这个运行的结果就是:12345subscribe123complete 注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件. RxJava引以为傲的链式操作：1234567891011121314151617181920212223242526272829Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "" + value); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;); ObservableEmitter和Disposable.ObservableEmitter：Emitte是发射器的意思，那就很好猜了，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。 发送事件遵循一定规则 上游可以发送无限个onNext, 下游也可以接收无限个onNext. 当上游发送了一个onComplete后, 上游 onComplete之后的事件将会继续发送, 而下游收到 onComplete事件之后将不再继续接收事件. 当上游发送了一个onError后, 上游 onError之后的事件将继续发送, 而下游收到onError事件之后将不再接收事件. 上游可以不发送onComplete或onError. 最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然 注: 关于onComplete和onError唯一并且互斥这一点, 是需要自行在代码中进行控制, 如果你的代码逻辑中违背了这个规则, 并不一定会导致程序崩溃. 比如发送多个onComplete是可以正常运行的, 依然是收到第一个onComplete就不再接收了, 但若是发送多个onError, 则收到第二个onError事件会导致程序会崩溃. 示意图 只发送onNext事件 next 发送onComplete事件 complete 发送onError事件 error Disposable对应于上面的水管的例子, 我们可以把它理解成两根管道之间的一个机关, 当调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件. 注意: 调用dispose()并不会导致上游不再继续发送事件, 上游会继续发送剩余的事件. 来看个例子, 我们让上游依次发送1,2,3,complete,4,在下游收到第二个事件之后, 切断水管, 看看运行结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); Log.d(TAG, "emit 4"); emitter.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private Disposable mDisposable; private int i; @Override public void onSubscribe(Disposable d) &#123; Log.d(TAG, "subscribe"); mDisposable = d; &#125; @Override public void onNext(Integer value) &#123; Log.d(TAG, "onNext: " + value); i++; if (i == 2) &#123; Log.d(TAG, "dispose"); mDisposable.dispose(); Log.d(TAG, "isDisposed : " + mDisposable.isDisposed()); &#125; &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG, "error"); &#125; @Override public void onComplete() &#123; Log.d(TAG, "complete"); &#125; &#125;); 运行结果为: 12345678910subscribeemit 1onNext: 1emit 2onNext: 2disposeisDisposed : trueemit 3emit completeemit 4 从运行结果我们看到, 在收到onNext 2这个事件后, 切断了水管, 但是上游仍然发送了3, complete, 4这几个事件, 而且上游并没有因为发送了onComplete而停止. 同时可以看到下游的onSubscribe()方法是最先调用的. 那如果有多个Disposable 该怎么办呢, RxJava中已经内置了一个容器CompositeDisposable, 每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可切断所有的水管. 另外, subscribe()有多个重载的方法: 123456public final Disposable subscribe() &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125; public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125; 最后一个带有Observer参数的我们已经使用过了,这里对其他几个方法进行说明. 不带任何参数的subscribe() 表示下游不关心任何事件,你上游尽管发你的数据去吧, 老子可不管你发什么. 带有一个Consumer参数的方法表示下游只关心onNext事件, 其他的事件我假装没看见, 因此我们如果只需要onNext事件可以这么写: 1234567891011121314151617181920Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, "emit 1"); emitter.onNext(1); Log.d(TAG, "emit 2"); emitter.onNext(2); Log.d(TAG, "emit 3"); emitter.onNext(3); Log.d(TAG, "emit complete"); emitter.onComplete(); Log.d(TAG, "emit 4"); emitter.onNext(4); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; Log.d(TAG, "onNext: " + integer); &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Android 学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TV 焦点框]]></title>
    <url>%2F2017%2F09%2F17%2FAndroid-TV-%E7%84%A6%E7%82%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[对于TV或者投影设备来说说，各种事件的处理，主要依赖于遥控器，通过焦点框来显示焦点出现的位置 一般可以通过响应事件来切换控件的背景（例：drawable/selector.xml），但是影响用户体验 通过焦点框的动画效果，使用平移动画绘制焦点框的移动轨迹，并且焦点框随着控件的形状而变化。动画最终状态是,焦点框从失去焦点的位置移动到获得焦点的位置,控件放大,焦点框尺寸最后变为放大后的控件尺寸. 设计思路 焦点框位于布局最上层，当控件获取焦点后，焦点框移动到控件上方 获取当前位置及大小 获取获取焦点控件的位置及大小 计算出平移距离及移动后的大小 开启动画，设置动画效果(移动时间及加速效果等) 自定义焦点框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 自定义焦点框 */public class FocusBorderView extends AppCompatButton &#123; private int moveCount;//记录次数，第一次不出现平移动画 public static final int TRAN_DUR_ANIM = 300;//平移时间 private static final int DEFAULT_BACKGROUND_RESOURCE_ID = R.drawable.icon_focus_border; private int fixX = 0;//x轴偏移量 private int fixY = 0;//y轴偏移量 public FocusBorderView(Context context) &#123; this(context, null); &#125; public FocusBorderView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public FocusBorderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FocusBorderView, defStyle, 0); setBackgroundResource(typedArray.getResourceId(R.styleable.FocusBorderView_focus_border_background, DEFAULT_BACKGROUND_RESOURCE_ID)); typedArray.recycle(); setFocusable(false); setClickable(false); &#125; public void runTranslateAnimation(View toView) &#123; runTranslateAnimation(toView, 1.0F, 1.0F); &#125; public void runTranslateAnimation(View toView, final float scaleX, final float scaleY) &#123; if (toView instanceof AbsListView) &#123; AbsListView absListView = (AbsListView) toView; absListView.setOnItemSelectedListener(new OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; runTranslateAnimation(view, scaleX, scaleY); &#125; public void onNothingSelected(AdapterView&lt;?&gt; parent) &#123; &#125; &#125;); toView = absListView.getSelectedView(); &#125; Rect fromRect = findLocationWithView(this); if (toView == null) &#123; return; &#125; Rect toRect = findLocationWithView(toView); int x = toRect.left - fromRect.left; int y = toRect.top - fromRect.top; int width = (int) (toView.getWidth() * scaleX); int height = (int) (toView.getHeight() * scaleY); int deltaX = (int) ((toView.getWidth() * Math.abs(scaleX - 1)) / 2.0f); int deltaY = (int) ((toView.getHeight() * Math.abs(scaleY - 1)) / 2.0f); x += fixX; y += fixY; flyWhiteBorder(width, height, x - deltaX, y - deltaY); &#125; /** * 焦点框飞动、移动、变大 * * @param width 框的宽 * @param height 框的高 * @param x x坐标偏移量，相对于初始的框的中心点 * @param y y坐标偏移量，相对于初始的框的中心点 */ @SuppressLint("NewApi") private void flyWhiteBorder(int width, int height, float x, float y) &#123; AnimatorSet animSet = new AnimatorSet(); animSet.play(ObjectAnimator.ofFloat(this, "x", x)).with(ObjectAnimator.ofFloat(this, "y", y)) .with(ObjectAnimator.ofInt(this, "width", this.getWidth(), width)) .with(ObjectAnimator.ofInt(this, "height", this.getHeight(), height)); animSet.setInterpolator(new DecelerateInterpolator()); animSet.addListener(flyListener); animSet.setDuration(TRAN_DUR_ANIM).start(); &#125; /** * 获取View的位置 * * @param view 获取的控件 * @return 位置 */ public Rect findLocationWithView(View view) &#123; ViewGroup root = (ViewGroup) this.getParent(); Rect rect = new Rect(); view.getDrawingRect(rect); root.offsetDescendantRectToMyCoords(view, rect); return rect; &#125; private Animator.AnimatorListener flyListener = new Animator.AnimatorListener() &#123; public void onAnimationCancel(Animator arg0) &#123; &#125; public void onAnimationEnd(Animator arg0) &#123; moveCount++; setVisibility(View.VISIBLE); &#125; public void onAnimationRepeat(Animator arg0) &#123; &#125; public void onAnimationStart(Animator arg0) &#123; if (moveCount != 0 &amp;&amp; getVisibility() != View.VISIBLE) &#123; setVisibility(View.VISIBLE); &#125; &#125; &#125;; public int getFixX() &#123; return fixX; &#125; public void setFixX(int fixX) &#123; this.fixX = fixX; &#125; public int getFixY() &#123; return fixY; &#125; public void setFixY(int fixY) &#123; this.fixY = fixY; &#125;``` ### 布局文件``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/root" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="cc.myandroid.focusborderviewdemo.MainActivity"&gt; &lt;GridLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:columnCount="4"&gt; &lt;TextView android:id="@+id/view_1" style="@style/ItemStyle" android:background="@color/color_menu_item_1" android:text="view1" /&gt; &lt;TextView android:id="@+id/view_2" style="@style/ItemStyle" android:background="@color/color_menu_item_2" android:text="view2" /&gt; &lt;TextView android:id="@+id/view_3" style="@style/ItemStyle" android:background="@color/color_menu_item_3" android:text="view3" /&gt; &lt;TextView android:id="@+id/view_4" style="@style/ItemStyle" android:background="@color/color_menu_item_4" android:text="view4" /&gt; &lt;TextView android:id="@+id/view_5" style="@style/ItemStyle" android:background="@color/color_menu_item_5" android:text="view5" /&gt; &lt;TextView android:id="@+id/view_6" style="@style/ItemStyle" android:background="@color/color_menu_item_6" android:text="view6" /&gt; &lt;TextView android:id="@+id/view_7" style="@style/ItemStyle" android:background="@color/color_menu_item_7" android:text="view7" /&gt; &lt;TextView android:id="@+id/view_8" style="@style/ItemStyle" android:background="@color/color_menu_item_8" android:text="view8" /&gt; &lt;/GridLayout&gt; &lt;cc.myandroid.focusborderviewdemo.FocusBorderView android:id="@+id/focus_border_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:focusable="false" android:visibility="invisible" /&gt;&lt;/FrameLayout&gt; Activity1234567891011121314151617181920212223import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.ViewTreeObserver;import android.widget.FrameLayout;public class MainActivity extends AppCompatActivity implements ViewTreeObserver.OnGlobalFocusChangeListener&#123; private FocusBorderView focusBorderView; private FrameLayout root; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); focusBorderView = (FocusBorderView) findViewById(R.id.focus_border_view); root = (FrameLayout) findViewById(R.id.root); root.getViewTreeObserver().addOnGlobalFocusChangeListener(this); &#125; @Override public void onGlobalFocusChanged(View oldFocus, View newFocus) &#123; focusBorderView.runTranslateAnimation(newFocus,1.2f,1.2f); &#125;&#125; 主要在根布局中添加监听，不用对每个控件单独设置监听 了解ViewTreeObserver ：解析 ViewTreeObserver 源码，体会观察者模式、Android消息传递（上） 在runTranslateAnimation方法中，可以根据获取焦点控件不同，设置不同的缩放值 文章博客地址 github地址]]></content>
      <categories>
        <category>Android</category>
        <category>Android TV开发笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android TV</tag>
      </tags>
  </entry>
</search>
